var documenterSearchIndex = {"docs":
[{"location":"examples/FractionalChernInsulatorOfHardCoreBosons/#Fractional-Chern-Insulator-of-Hard-core-Bosons-on-honeycomb-lattice","page":"Fractional Chern Insulator of Hard-core Bosons on honeycomb lattice","title":"Fractional Chern Insulator of Hard-core Bosons on honeycomb lattice","text":"","category":"section"},{"location":"examples/FractionalChernInsulatorOfHardCoreBosons/#Many-body-energy-levels-as-a-function-of-twisted-boundary-conditions","page":"Fractional Chern Insulator of Hard-core Bosons on honeycomb lattice","title":"Many-body energy levels as a function of twisted boundary conditions","text":"","category":"section"},{"location":"examples/FractionalChernInsulatorOfHardCoreBosons/","page":"Fractional Chern Insulator of Hard-core Bosons on honeycomb lattice","title":"Fractional Chern Insulator of Hard-core Bosons on honeycomb lattice","text":"The following codes could compute the many-body energy levels as a function of twisted boundary conditions of hard-core bosons on honeycomb lattice with a nearly-flat Chern band.","category":"page"},{"location":"examples/FractionalChernInsulatorOfHardCoreBosons/","page":"Fractional Chern Insulator of Hard-core Bosons on honeycomb lattice","title":"Fractional Chern Insulator of Hard-core Bosons on honeycomb lattice","text":"using QuantumLattices\nusing ExactDiagonalization\nusing LinearAlgebra: eigen\nusing Plots: plot\n\n# unit cell of the honeycomb lattice\nunitcell = Lattice([0.0, 0.0], [0.0, ‚àö3/3]; vectors=[[1.0, 0.0], [0.5, ‚àö3/2]])\n\n# 4√ó3 cluster\nlattice = Lattice(unitcell, (4, 3), ('P', 'P'))\n\n# twisted boundary condition\nboundary = Boundary{(:Œ∏‚ÇÅ, :Œ∏‚ÇÇ)}([0.0, 0.0], lattice.vectors)\n\n# Hilbert space of hard-core bosons\nhilbert = Hilbert(Fock{:b}(1, 1), length(lattice))\n\n# Parameters of the model, with hoppings up to 3rd nearest neighbor and interactions up to 2nd\n# the 2nd nearest neighbor hopping is complex, similar to that of the Haldane model\n# with such parameters, the model host a nearly flat band with ¬±1 Chern number\nparameters = (\n    t=Complex(-1.0), t‚Ä≤=Complex(-0.6), t‚Ä≤‚Ä≤=Complex(0.58), œÜ=0.4, V‚ÇÅ=1.0, V‚ÇÇ=0.4, Œ∏‚ÇÅ=0.0, Œ∏‚ÇÇ=0.0\n)\nmap(parameters::NamedTuple) = (\n    t‚ÇÅ=parameters.t,\n    t‚ÇÇ=parameters.t‚Ä≤*cos(parameters.œÜ*pi),\n    Œª‚ÇÇ=parameters.t‚Ä≤*sin(parameters.œÜ*pi),\n    t‚ÇÉ=parameters.t‚Ä≤‚Ä≤,\n    V‚ÇÅ=parameters.V‚ÇÅ,\n    V‚ÇÇ=parameters.V‚ÇÇ,\n    Œ∏‚ÇÅ=parameters.Œ∏‚ÇÅ,\n    Œ∏‚ÇÇ=parameters.Œ∏‚ÇÇ\n)\n\n# terms\nt‚ÇÅ = Hopping(:t‚ÇÅ, map(parameters).t‚ÇÅ, 1; ismodulatable=false)\nt‚ÇÇ = Hopping(:t‚ÇÇ, map(parameters).t‚ÇÇ, 2; ismodulatable=false)\nŒª‚ÇÇ = Hopping(:Œª‚ÇÇ, map(parameters).Œª‚ÇÇ, 2;\n    amplitude=bond::Bond->1im*cos(3*azimuth(rcoordinate(bond)))*(-1)^(bond[1].site%2),\n    ismodulatable=false\n)\nt‚ÇÉ = Hopping(:t‚ÇÉ, map(parameters).t‚ÇÉ, 3; ismodulatable=false)\nV‚ÇÅ = Coulomb(:V‚ÇÅ, map(parameters).V‚ÇÅ, 1)\nV‚ÇÇ = Coulomb(:V‚ÇÇ, map(parameters).V‚ÇÇ, 2)\n\n# 1/4 filling of the model, i.e., half-filling of the lower flat Chern band\n# In such case, the ground state of the model is a bosonic fractional Chern insulator\n# see Y.-F. Wang, et al. PRL 107, 146803 (2011)\nquantumnumber = ‚Ñï(length(lattice)√∑4)\n\n# construct the algorithm\nfci = Algorithm(\n    :FCI,\n    ED(lattice, hilbert, (t‚ÇÅ, t‚ÇÇ, Œª‚ÇÇ, t‚ÇÉ, V‚ÇÅ, V‚ÇÇ), quantumnumber, boundary),\n    parameters,\n    map\n)\n\n# define the boundary angles and number of energy levels to be computed\nnŒ∏, nev = 5, 3\nŒ∏s = range(0, 2, nŒ∏)\ndata = zeros(nŒ∏, nev)\n\n# compute the energy levels with different twist boundary angles\nfor (i, Œ∏) in enumerate(Œ∏s)\n    update!(fci; Œ∏‚ÇÅ=Œ∏)\n    data[i, :] = eigen(fci; nev=nev).values\nend\n\n# plot the result\nplot(Œ∏s, data; legend=false)","category":"page"},{"location":"examples/HeisenbergModel/#Antiferromagnetic-Heisenberg-Model-on-square-lattice","page":"Antiferromagnetic Heisenberg Model on square lattice","title":"Antiferromagnetic Heisenberg Model on square lattice","text":"","category":"section"},{"location":"examples/HeisenbergModel/#Ground-state-energy","page":"Antiferromagnetic Heisenberg Model on square lattice","title":"Ground state energy","text":"","category":"section"},{"location":"examples/HeisenbergModel/","page":"Antiferromagnetic Heisenberg Model on square lattice","title":"Antiferromagnetic Heisenberg Model on square lattice","text":"The following codes could compute the ground state energy of the antiferromagnetic Heisenberg model on square lattice.","category":"page"},{"location":"examples/HeisenbergModel/","page":"Antiferromagnetic Heisenberg Model on square lattice","title":"Antiferromagnetic Heisenberg Model on square lattice","text":"using QuantumLattices\nusing ExactDiagonalization\nusing LinearAlgebra: eigen\n\n# define the unitcell of the square lattice\nunitcell = Lattice([0.0, 0.0]; name=:Square, vectors=[[1.0, 0.0], [0.0, 1.0]])\n\n# define a finite 4√ó4 cluster of the square lattice with open boundary condition\nlattice = Lattice(unitcell, (4, 4))\n\n# define the Hilbert space (spin-1/2)\nhilbert = Hilbert(Spin{1//2}(), length(lattice))\n\n# define the quantum number of the sub-Hilbert space in which the computation to be carried out\n# for the ground state, Sz=0\nquantumnumber = ùïä·∂ª(0)\n\n# define the antiferromagnetic Heisenberg term on the nearest neighbor\nJ = Heisenberg(:J, 1.0, 1)\n\n# define the exact diagonalization algorithm for the antiferromagnetic Heisenberg model\ned = ED(lattice, hilbert, J, quantumnumber)\n\n# find the ground state and its energy\neigensystem = eigen(ed; nev=1)\n\n# Ground state energy should be -9.189207065192935\nprint(eigensystem.values)","category":"page"},{"location":"manual/BandLanczos/#Band-Lanczos","page":"Band Lanczos","title":"Band Lanczos","text":"","category":"section"},{"location":"manual/BandLanczos/#ExactDiagonalization.BandLanczos.BandLanczosFactorization","page":"Band Lanczos","title":"ExactDiagonalization.BandLanczos.BandLanczosFactorization","text":"BandLanczosFactorization{T, S<:Number, SR<:Real} <: KrylovFactorization{T, S}\n\nBand Lanczos factorization, same to KrylovKit.BlockLanczosFactorization except that the Krylov basis vectors can be chosen to be kept or not.\n\n\n\n\n\n","category":"type"},{"location":"manual/BandLanczos/#ExactDiagonalization.BandLanczos.BandLanczosIterator","page":"Band Lanczos","title":"ExactDiagonalization.BandLanczos.BandLanczosIterator","text":"BandLanczosIterator{F, T, S<:Real} <: KrylovIterator{F, T}\n\nBand Lanczos iterator.\n\n\n\n\n\n","category":"type"},{"location":"manual/BandLanczos/#ExactDiagonalization.BandLanczos.BandLanczosIterator-Union{Tuple{T}, Tuple{Any, KrylovKit.Block{T}, Int64}, Tuple{Any, KrylovKit.Block{T}, Int64, Real}} where T","page":"Band Lanczos","title":"ExactDiagonalization.BandLanczos.BandLanczosIterator","text":"BandLanczosIterator(operator, x‚ÇÄ::Block, maxdim::Int, tol::Real=1e-12; keepvecs::Bool=true)\n\nConstruct a BandLanczosIterator.\n\n\n\n\n\n","category":"method"},{"location":"manual/BandLanczos/#KrylovKit.expand!-Tuple{ExactDiagonalization.BandLanczos.BandLanczosIterator, ExactDiagonalization.BandLanczos.BandLanczosFactorization}","page":"Band Lanczos","title":"KrylovKit.expand!","text":"expand!(iter::BandLanczosIterator, state::BandLanczosFactorization) -> BandLanczosFactorization\n\nExpand an BandLanczosFactorization.\n\n\n\n\n\n","category":"method"},{"location":"manual/BandLanczos/#KrylovKit.initialize-Tuple{ExactDiagonalization.BandLanczos.BandLanczosIterator}","page":"Band Lanczos","title":"KrylovKit.initialize","text":"initialize(iter::BandLanczosIterator) -> BandLanczosFactorization\n\nInitialize a BandLanczosFactorization by a BandLanczosIterator.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Core-of-ExactDiagonalization","page":"Core of ExactDiagonalization","title":"Core of ExactDiagonalization","text":"","category":"section"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.basicoptions","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.basicoptions","text":"const basicoptions = (\n    nev = \"number of eigenvalues to be computed\",\n    which = \"type of eigenvalues to be computed\",\n    tol = \"tolerance of the computation\",\n    maxiter = \"maximum iteration of the computation\",\n    v‚ÇÄ = \"initial state\",\n    krylovdim = \"maximum dimension of the Krylov subspace that will be constructed\",\n    verbosity = \"verbosity level\"\n)\n\nBasic options of actions for exact diagonalization method.\n\n\n\n\n\n","category":"constant"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.edtimer","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.edtimer","text":"const edtimer = TimerOutput()\n\nDefault shared timer for all exact diagonalization methods.\n\n\n\n\n\n","category":"constant"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.AbelianBases","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.AbelianBases","text":"AbelianBases{A<:Abelian, N} <: Sector\n\nA set of Abelian bases, that is, a set of bases composed from the product of local Abelian Graded spaces.\n\nTo improve the efficiency of the product of local Abelian Graded spaces, we adopt a two-step strategy:\n\npartition the local spaces into several groups in each of which the local spaces are direct producted and rearranged according to the Abelian quantum numbers, and then \nglue the results obtained in the previous step so that a sector with a certain Abelian quantum number can be targeted.\n\nIn principle, a binary-tree strategy can be more efficient, but our two-step strategy is enough for a quantum system that can be solved by the exact diagonalization method.\n\nThe partition of the local Abelian Graded spaces is assigned by a NTuple{N, Vector{Int}}, with each of its element contains the sequences of the grouped local spaces specified by a table.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.AbelianBases-Union{Tuple{AbstractVector{Int64}}, Tuple{N}, Tuple{AbstractVector{Int64}, NTuple{N, AbstractVector{Int64}}}} where N","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.AbelianBases","text":"AbelianBases(locals::AbstractVector{Int}, partition::NTuple{N, AbstractVector{Int}}=partition(length(locals))) where N\n\nConstruct a set of spin bases that subjects to no quantum number conservation.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.AbelianBases-Union{Tuple{A}, Tuple{N}, Tuple{Array{ExactDiagonalization.QuantumNumbers.AbelianGradedSpace{A}, 1}, A}, Tuple{Array{ExactDiagonalization.QuantumNumbers.AbelianGradedSpace{A}, 1}, A, NTuple{N, AbstractVector{Int64}}}} where {N, A<:ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.AbelianBases","text":"AbelianBases(locals::Vector{Graded{A}}, quantumnumber::A, partition::NTuple{N, AbstractVector{Int}}=partition(length(locals))) where {N, A<:Abelian}\n\nConstruct a set of spin bases that preserves a certain symmetry specified by the corresponding Abelian quantum number.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.BinaryBases","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.BinaryBases","text":"BinaryBases{A<:Abelian, B<:BinaryBasis, T<:AbstractVector{B}} <: Sector\n\nA set of binary bases.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.BinaryBases-Tuple{Any, Any, ‚Ñï ‚ä† ùïä·∂ª}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.BinaryBases","text":"BinaryBases(spindws, spinups, spinfulparticle::Abelian[‚Ñï ‚ä† ùïä·∂ª])\nBinaryBases(spindws, spinups, spinfulparticle::Abelian[ùïä·∂ª ‚ä† ‚Ñï])\n\nConstruct a set of binary bases that preserves both the particle number and the spin z-component conservation.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.BinaryBases-Tuple{Any, Any, ùïä·∂ª}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.BinaryBases","text":"BinaryBases(spindws, spinups, sz::ùïä·∂ª)\n\nConstruct a set of binary bases that preserves the spin z-component but not the particle number conservation.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.BinaryBases-Tuple{Integer, ‚Ñï}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.BinaryBases","text":"BinaryBases(states, particle::‚Ñï)\nBinaryBases(nstate::Integer, particle::‚Ñï)\n\nConstruct a set of binary bases that preserves the particle number conservation.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.BinaryBases-Tuple{Integer}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.BinaryBases","text":"BinaryBases(states)\nBinaryBases(nstate::Integer)\n\nConstruct a set of binary bases that subjects to no quantum number conservation.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.BinaryBasis","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.BinaryBasis","text":"BinaryBasis{I<:Unsigned}\n\nBinary basis represented by an unsigned integer.\n\nHere, we adopt the following common rules:\n\nIn a binary basis, a bit of an unsigned integer represents a single-particle state that can be occupied (1) or unoccupied (0).\nThe position of this bit in the unsigned integer counting from the right corresponds to the sequence of the single-particle state specified by a table.\nWhen representing a many-body state by creation operators, they are arranged in ascending order according to their sequences.\n\nIn this way, any many-body state of canonical fermionic or hardcore bosonic systems can be represented ambiguously by the binary bases, e.g., c^_2c^_3c^_4textVacuumrangle is represented by 1110.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.BinaryBasis-Tuple{Any}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.BinaryBasis","text":"BinaryBasis(states; filter=index->true)\nBinaryBasis{I}(states; filter=index->true) where {I<:Unsigned}\n\nConstruct a binary basis with the given occupied states.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.BinaryBasisRange","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.BinaryBasisRange","text":"BinaryBasisRange{I<:Unsigned} <: VectorSpace{BinaryBasis{I}}\n\nA continuous range of binary basis from 0 to 2^n-1.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.ED","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.ED","text":"ED(system::Generator{<:Operators}, table::AbstractDict, sectors::OneOrMore{Sector}, dtype::Type{<:Number}=scalartype(system))\nED(lattice::Union{AbstractLattice, Nothing}, system::Generator{<:Operators}, table::AbstractDict, sectors::OneOrMore{Sector}, dtype::Type{<:Number}=scalartype(system))\n\nConstruct the exact diagonalization method for a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.ED-2","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.ED","text":"ED(\n    lattice::AbstractLattice, hilbert::Hilbert, terms::OneOrMore{Term}, quantumnumbers::OneOrMore{Abelian}, boundary::Boundary=plain, dtype::Type{<:Number}=valtype(terms);\n    neighbors::Union{Int, Neighbors}=nneighbor(terms)\n)\nED(\n    lattice::AbstractLattice, hilbert::Hilbert, terms::OneOrMore{Term}, table::AbstractDict, quantumnumbers::OneOrMore{Abelian}, boundary::Boundary=plain, dtype::Type{<:Number}=valtype(terms);\n    neighbors::Union{Int, Neighbors}=nneighbor(terms)\n)\n\nConstruct the exact diagonalization method for a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.ED-3","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.ED","text":"ED(\n    lattice::AbstractLattice, hilbert::Hilbert, terms::OneOrMore{Term}, boundary::Boundary=plain, dtype::Type{<:Number}=valtype(terms);\n    neighbors::Union{Int, Neighbors}=nneighbor(terms)\n)\nED(\n    lattice::AbstractLattice, hilbert::Hilbert, terms::OneOrMore{Term}, table::AbstractDict, sectors::OneOrMore{Sector}=Sector(hilbert; table=table), boundary::Boundary=plain, dtype::Type{<:Number}=valtype(terms);\n    neighbors::Union{Int, Neighbors}=nneighbor(terms)\n)\n\nConstruct the exact diagonalization method for a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.ED-4","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.ED","text":"ED{K<:EDKind, L<:Union{AbstractLattice, Nothing}, S<:Generator{<:Operators}, M<:EDMatrixization, H<:CategorizedGenerator{<:OperatorSum{<:EDMatrix}}} <: Frontend\n\nExact diagonalization method of a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDEigen","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDEigen","text":"EDEigen{S<:Tuple{Vararg{Union{Abelian, Sector}}}} <: Action\n\nEigen system by exact diagonalization method.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDEigen-Tuple{Vararg{Union{Sector, ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber}}}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDEigen","text":"EDEigen(sectors::Union{Abelian, Sector}...)\nEDEigen(sectors:::Tuple{Vararg{Union{Abelian, Sector}}})\n\nConstruct an EDEigen.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDEigenData","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDEigenData","text":"EDEigenData{V<:Number, T<:Number, S<:Sector} <: Data\n\nEigen decomposition in exact diagonalization method.\n\nCompared to the usual eigen decomposition Eigen, EDEigenData contains a :sectors attribute to store the sectors of Hilbert space in which the eigen values and eigen vectors are computed. Furthermore, given that in different sectors the dimensions of the sub-Hilbert spaces can also be different, the :vectors attribute of EDEigenData is a vector of vector instead of a matrix.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDKind","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDKind","text":"EDKind{K}\n\nKind of the exact diagonalization method applied to a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDKind-Tuple{Type{<:QuantumLattices.QuantumSystems.FockIndex}}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDKind","text":"EDKind(::Type{<:FockIndex})\n\nKind of the exact diagonalization method applied to a canonical quantum Fock lattice system.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDKind-Tuple{Type{<:QuantumLattices.QuantumSystems.SpinIndex}}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDKind","text":"EDKind(::Type{<:SpinIndex})\n\nKind of the exact diagonalization method applied to a canonical quantum spin lattice system.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDMatrix","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDMatrix","text":"EDMatrix{M<:SparseMatrixCSC, S<:Sector} <: OperatorPack{M, Tuple{S, S}}\n\nMatrix representation of quantum operators between a ket Hilbert space and a bra Hilbert space.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDMatrix-Tuple{SparseArrays.SparseMatrixCSC, Sector}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDMatrix","text":"EDMatrix(m::SparseMatrixCSC, sector::Sector)\nEDMatrix(m::SparseMatrixCSC, braket::NTuple{2, Sector})\nEDMatrix(m::SparseMatrixCSC, bra::Sector, ket::Sector)\n\nConstruct a matrix representation when\n\nthe bra and ket Hilbert spaces share the same bases;\nthe bra and ket Hilbert spaces may be different;\nthe bra and ket Hilbert spaces may or may not be the same.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDMatrixization","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDMatrixization","text":"EDMatrixization{D<:Number, T<:AbstractDict, S<:Sector} <: Matrixization\n\nMatrixization of a quantum lattice system on a target Hilbert space.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDMatrixization-Union{Tuple{S}, Tuple{D}, Tuple{AbstractDict, S, Vararg{S}}} where {D<:Number, S<:Sector}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDMatrixization","text":"EDMatrixization{D}(table::AbstractDict, sector::S, sectors::S...) where {D<:Number, S<:Sector}\nEDMatrixization{D}(table::AbstractDict, brakets::Vector{Tuple{S, S}}) where {D<:Number, S<:Sector}\n\nConstruct a matrixization.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.GroundStateExpectation","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.GroundStateExpectation","text":"GroundStateExpectation{D<:Number, O<:Array{<:Union{Operator, Operators}}} <: Action\n\nGround state expectation of operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.GroundStateExpectationData","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.GroundStateExpectationData","text":"GroundStateExpectationData{A<:Array{<:Number}} <: Data\n\nData of ground state expectation of operators, including:\n\nvalues::A: values of the ground state expectation.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.QuantumNumbers.Abelian-Tuple{AbelianBases}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.QuantumNumbers.Abelian","text":"Abelian(bs::AbelianBases)\n\nGet the Abelian quantum number of a set of spin bases.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.QuantumNumbers.Abelian-Tuple{BinaryBases}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.QuantumNumbers.Abelian","text":"Abelian(bs::BinaryBases)\n\nGet the Abelian quantum number of a set of binary bases.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.QuantumNumbers.Graded-Union{Tuple{QuantumLattices.QuantumSystems.Spin}, Tuple{‚Ñ§‚ÇÅ}} where ‚Ñ§‚ÇÅ","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.QuantumNumbers.Graded","text":"Graded{‚Ñ§‚ÇÅ}(spin::Spin)\nGraded{ùïä·∂ª}(spin::Spin)\n\nDecompose a local spin space into an Abelian graded space that preserves 1) no symmetry, and 2) spin-z component symmetry.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.Sector","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.Sector","text":"Sector(hilbert::Hilbert{<:Spin}, partition::Tuple{Vararg{AbstractVector{Int}}}=partition(length(hilbert))) -> AbelianBases\nSector(\n    quantumnumber::Abelian, hilbert::Hilbert{<:Spin}, partition::Tuple{Vararg{AbstractVector{Int}}}=partition(length(hilbert));\n    table::AbstractDict=Table(hilbert, Metric(EDKind(hilbert), hilbert))\n) -> AbelianBases\n\nConstruct the Abelian bases of a spin Hilbert space with the specified quantum number.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.Sector-2","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.Sector","text":"Sector(hilbert::Hilbert{<:Fock}, basistype::Type{<:Unsigned}=UInt) -> BinaryBases\nSector(quantumnumber::‚Ñï, hilbert::Hilbert{<:Fock}, basistype::Type{<:Unsigned}=UInt; table::AbstractDict=Table(hilbert, Metric(EDKind(hilbert), hilbert))) -> BinaryBases\nSector(quantumnumber::Union{ùïä·∂ª, Abelian[‚Ñï ‚ä† ùïä·∂ª], Abelian[ùïä·∂ª ‚ä† ‚Ñï]}, hilbert::Hilbert{<:Fock}, basistype::Type{<:Unsigned}=UInt; table::AbstractDict=Table(hilbert, Metric(EDKind(hilbert), hilbert))) -> BinaryBases\n\nConstruct the binary bases of a Hilbert space with the specified quantum number.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.Sector-3","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.Sector","text":"Sector\n\nA sector of the Hilbert space which forms the bases of an irreducible representation of the Hamiltonian of a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.SectorFilter","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.SectorFilter","text":"SectorFilter{S} <: LinearTransformation\n\nFilter the target bra and ket Hilbert spaces.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.SpinCoherentState","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.SpinCoherentState","text":"SpinCoherentState <: CompositeDict{Int, Tuple{Float64, Float64}}\n\nSpin coherent state on a block of lattice sites.\n\nThe structure of the spin coherent state is specified by a Dict{Int, Tuple{Float64, Float64}}, which contains the site-(Œ∏, œï) pairs with site being the site index in a lattice and (Œ∏, œï) denoting the polar and azimuth angles in radians of the classical magnetic moment on this site.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.SpinCoherentState-2","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.SpinCoherentState","text":"(state::SpinCoherentState)(bases::AbelianBases, table::AbstractDict, dtype=ComplexF64) -> Vector{dtype}\n\nGet the vector representation of a spin coherent state with the given Abelian bases and table.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.SpinCoherentState-Tuple{AbstractDict{Int64, <:AbstractVector{<:Number}}}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.SpinCoherentState","text":"SpinCoherentState(structure::AbstractDict{Int, <:AbstractVector{<:Number}})\nSpinCoherentState(structure::AbstractDict{Int, <:NTuple{2, Number}}; unit::Symbol=:radian)\n\nConstruct a spin coherent state on a block of lattice sites.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.SpinCoherentStateProjection","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.SpinCoherentStateProjection","text":"SpinCoherentStateProjection <: Action\n\nProjection of states obtained by exact diagonalization method onto spin coherent states.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.SpinCoherentStateProjection-Tuple{SpinCoherentState, Integer, Integer}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.SpinCoherentStateProjection","text":"SpinCoherentStateProjection(configuration::SpinCoherentState, polars::AbstractVector{<:Real}, azimuths::AbstractVector{<:Real})\nSpinCoherentStateProjection(configuration::SpinCoherentState, np::Integer, na::Integer)\n\nConstruct a SpinCoherentStateProjection.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.SpinCoherentStateProjectionData","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.SpinCoherentStateProjectionData","text":"SpinCoherentStateProjectionData <: Data\n\nData of spin coherent state projection, including:\n\npolars::Vector{Float64}: global polar angles of the spin coherent states.\nazimuths::Vector{Float64}: global azimuth angles of the spin coherent states.\nvalues::Matrix{Float64}: projection of the state obtained by exact diagonalization method onto the spin coherent states.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.StaticTwoPointCorrelator","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.StaticTwoPointCorrelator","text":"StaticTwoPointCorrelator{O<:Union{Operator, Operators}, R<:ReciprocalSpace} <: Action\n\nStatic two-point correlation function.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.StaticTwoPointCorrelatorData","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.StaticTwoPointCorrelatorData","text":"StaticTwoPointCorrelatorData{R<:ReciprocalSpace, V<:Array{Float64}} <: Data\n\nData of static two-point correlation function, including:\n\nreciprocalspace::R: reciprocal space to compute the static two-point correlation function.\nvalues::V: values of the static two-point correlation function.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#QuantumLattices.DegreesOfFreedom.Metric-Tuple{EDKind{:Abelian}, QuantumLattices.DegreesOfFreedom.Hilbert{<:QuantumLattices.QuantumSystems.Spin}}","page":"Core of ExactDiagonalization","title":"QuantumLattices.DegreesOfFreedom.Metric","text":"Metric(::EDKind{:Abelian}, ::Hilbert{<:Spin}) -> OperatorIndexToTuple\n\nGet the index-to-tuple metric for a canonical quantum spin lattice system.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.DegreesOfFreedom.Metric-Tuple{EDKind{:Binary}, QuantumLattices.DegreesOfFreedom.Hilbert{<:QuantumLattices.QuantumSystems.Fock}}","page":"Core of ExactDiagonalization","title":"QuantumLattices.DegreesOfFreedom.Metric","text":"Metric(::EDKind{:Binary}, ::Hilbert{<:Fock}) -> OperatorIndexToTuple\n\nGet the index-to-tuple metric for a canonical quantum Fock lattice system.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.Broadcast.broadcast-Tuple{Type{Sector}, Tuple{ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber, Vararg{ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber, N}} where N, QuantumLattices.DegreesOfFreedom.Hilbert, Vararg{Any}}","page":"Core of ExactDiagonalization","title":"Base.Broadcast.broadcast","text":"broadcast(::Type{Sector}, quantumnumbers::OneAtLeast{Abelian}, hilbert::Hilbert, args...; table::AbstractDict=Table(hilbert, Metric(EDKind(hilbert), hilbert))) -> NTuple{fieldcount(typeof(quantumnumbers)), Sector}\n\nConstruct a set of sectors based on the quantum numbers and a Hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.Broadcast.broadcast-Union{Tuple{A}, Tuple{N}, Tuple{Type{Sector}, Tuple{A, Vararg{A, N}} where N, QuantumLattices.DegreesOfFreedom.Hilbert{<:QuantumLattices.QuantumSystems.Spin}}, Tuple{Type{Sector}, Tuple{A, Vararg{A, N}} where N, QuantumLattices.DegreesOfFreedom.Hilbert{<:QuantumLattices.QuantumSystems.Spin}, NTuple{N, AbstractVector{Int64}}}} where {N, A<:ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber}","page":"Core of ExactDiagonalization","title":"Base.Broadcast.broadcast","text":"broadcast(\n    ::Type{Sector}, quantumnumbers::OneAtLeast{Abelian}, hilbert::Hilbert{<:Spin}, partition::NTuple{N, AbstractVector{Int}}=partition(length(hilbert));\n    table::AbstractDict=Table(hilbert, Metric(EDKind(hilbert), hilbert))\n) where N -> NTuple{fieldcount(typeof(quantumnumbers)), AbelianBases}\n\nConstruct a set of Abelian based based on the quantum numbers and a Hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.count-Tuple{BinaryBasis}","page":"Core of ExactDiagonalization","title":"Base.count","text":"count(basis::BinaryBasis) -> Int\ncount(basis::BinaryBasis, start::Integer, stop::Integer) -> Int\n\nCount the number of occupied single-particle states for a binary basis.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.count-Tuple{EDEigenData}","page":"Core of ExactDiagonalization","title":"Base.count","text":"count(data::EDEigenData) -> Int\n\nCount the number of eigen value-vector-sector groups contained in an EDEigenData.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.isone-Tuple{BinaryBasis, Integer}","page":"Core of ExactDiagonalization","title":"Base.isone","text":"isone(basis::BinaryBasis, state::Integer) -> Bool\n\nJudge whether the specified single-particle state is occupied for a binary basis.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.iszero-Tuple{BinaryBasis, Integer}","page":"Core of ExactDiagonalization","title":"Base.iszero","text":"iszero(basis::BinaryBasis, state::Integer) -> Bool\n\nJudge whether the specified single-particle state is unoccupied for a binary basis.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.iterate","page":"Core of ExactDiagonalization","title":"Base.iterate","text":"iterate(basis::BinaryBasis)\niterate(basis::BinaryBasis, state)\n\nIterate over the numbers of the occupied single-particle states.\n\n\n\n\n\n","category":"function"},{"location":"manual/ExactDiagonalization/#Base.match-Tuple{Sector, Sector}","page":"Core of ExactDiagonalization","title":"Base.match","text":"match(sector‚ÇÅ::Sector, sector‚ÇÇ::Sector) -> Bool\n\nJudge whether two sectors match each other, that is, whether they can be used together as the bra and ket spaces.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.one-Tuple{BinaryBasis, Integer}","page":"Core of ExactDiagonalization","title":"Base.one","text":"one(basis::BinaryBasis, state::Integer) -> BinaryBasis\n\nGet a new binary basis with the specified single-particle state occupied.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.range-Tuple{AbelianBases{‚Ñ§‚ÇÅ}}","page":"Core of ExactDiagonalization","title":"Base.range","text":"range(bs::AbelianBases) -> AbstractVector{Int}\n\nGet the range of the target sector of an AbelianBases in the direct producted bases.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.zero-Tuple{BinaryBasis, Integer}","page":"Core of ExactDiagonalization","title":"Base.zero","text":"zero(basis::BinaryBasis, state::Integer) -> BinaryBasis\n\nGet a new binary basis with the specified single-particle state unoccupied.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.QuantumNumbers.:‚ä†-Tuple{BinaryBases, ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.QuantumNumbers.:‚ä†","text":"‚ä†(bs::BinaryBases, another::Abelian) -> BinaryBases\n‚ä†(another::Abelian, bs::BinaryBases) -> BinaryBases\n\nDeligne tensor product the quantum number of a set of binary bases with another quantum number.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.basistype-Tuple{Integer}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.basistype","text":"basistype(i::Integer)\nbasistype(::Type{I}) where {I<:Integer}\n\nGet the binary basis type corresponding to an integer or a type of an integer.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.prepare!-Tuple{ED}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.prepare!","text":"prepare!(ed::ED; timer::TimerOutput=edtimer) -> ED\nprepare!(ed::Algorithm{<:ED}) -> Algorithm{<:ED}\n\nPrepare the matrix representation.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.productable-Tuple{Sector, Sector}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.productable","text":"productable(sector‚ÇÅ::Sector, sector‚ÇÇ::Sector) -> Bool\n\nJudge whether two sectors could be direct producted.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.release!-Tuple{ED}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.release!","text":"release!(ed::ED; gc::Bool=true) -> ED\nrelease!(ed::Algorithm{<:ED}; gc::Bool=true) -> Algorithm{<:ED}\n\nRelease the memory source used in preparing the matrix representation. If gc is true, call the garbage collection immediately.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.sumable-Tuple{Sector, Sector}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.sumable","text":"sumable(sector‚ÇÅ::Sector, sector‚ÇÇ::Sector) -> Bool\n\nJudge whether two sectors could be direct summed.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#LinearAlgebra.eigen-Tuple{ED, Vararg{Union{Sector, ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber}}}","page":"Core of ExactDiagonalization","title":"LinearAlgebra.eigen","text":"eigen(ed::ED, sectors::Union{Abelian, Sector}...; timer::TimerOutput=edtimer, release::Bool=false, kwargs...) -> EDEigenData\neigen(ed::Algorithm{<:ED}, sectors::Union{Abelian, Sector}...; release::Bool=false, kwargs...) -> EDEigenData\n\nSolve the eigen problem by the restarted Lanczos method provided by the Arpack package.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#LinearAlgebra.eigen-Tuple{EDMatrix}","page":"Core of ExactDiagonalization","title":"LinearAlgebra.eigen","text":"eigen(m::EDMatrix; nev::Int=1, which::Symbol=:SR, tol::Real=1e-12, maxiter::Int=300, v‚ÇÄ::Union{AbstractVector{<:Number}, Int}=dimension(m.bra), krylovdim::Int=max(20, 2*nev+1), verbosity::Int=0) -> EDEigenData\n\nSolve the eigen problem by the restarted Lanczos method provided by the KrylovKit package.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#LinearAlgebra.eigen-Tuple{QuantumLattices.QuantumOperators.OperatorSum{<:EDMatrix}}","page":"Core of ExactDiagonalization","title":"LinearAlgebra.eigen","text":"eigen(\n    ms::OperatorSum{<:EDMatrix};\n    nev::Int=1,\n    which::Symbol=:SR,\n    tol::Real=1e-12,\n    maxiter::Int=300,\n    v‚ÇÄ::Union{Dict{<:Abelian, <:Union{AbstractVector{<:Number}, Int}}, Dict{<:Sector, <:Union{AbstractVector{<:Number}, Int}}}=Dict(Abelian(m.ket)=>dimension(m.ket) for m in ms),\n    krylovdim::Int=max(20, 2*nev+1),\n    verbosity::Int=0,\n    timer::TimerOutput=edtimer\n) -> EDEigenData\n\nSolve the eigen problem by the restarted Lanczos method provided by the Arpack package.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.:‚äó-Tuple{BinaryBases, BinaryBases}","page":"Core of ExactDiagonalization","title":"QuantumLattices.:‚äó","text":"‚äó(bs‚ÇÅ::BinaryBases, bs‚ÇÇ::BinaryBases) -> BinaryBases\n\nGet the direct product of two sets of binary bases.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.:‚äó-Tuple{BinaryBasis, BinaryBasis}","page":"Core of ExactDiagonalization","title":"QuantumLattices.:‚äó","text":"‚äó(basis‚ÇÅ::BinaryBasis, basis‚ÇÇ::BinaryBasis) -> BinaryBasis\n\nGet the direct product of two binary bases.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.DegreesOfFreedom.partition-Tuple{Int64}","page":"Core of ExactDiagonalization","title":"QuantumLattices.DegreesOfFreedom.partition","text":"partition(n::Int) -> NTuple{2, Vector{Int}}\n\nGet the default partition of n local Hilbert spaces.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.QuantumOperators.matrix","page":"Core of ExactDiagonalization","title":"QuantumLattices.QuantumOperators.matrix","text":"matrix(ops::Operators, braket::NTuple{2, Sector}, table::AbstractDict, dtype=scalartype(ops)) -> SparseMatrixCSC{dtype, Int}\n\nGet the CSC-formed sparse matrix representation of a set of operators.\n\nHere, table specifies the order of the operator indexes.\n\n\n\n\n\n","category":"function"},{"location":"manual/ExactDiagonalization/#QuantumLattices.QuantumOperators.matrix-2","page":"Core of ExactDiagonalization","title":"QuantumLattices.QuantumOperators.matrix","text":"matrix(index::OperatorIndex, graded::Graded, dtype::Type{<:Number}=ComplexF64) -> Matrix{dtype}\n\nGet the matrix representation of an OperatorIndex on an Abelian graded space.\n\n\n\n\n\n","category":"function"},{"location":"manual/ExactDiagonalization/#QuantumLattices.QuantumOperators.matrix-3","page":"Core of ExactDiagonalization","title":"QuantumLattices.QuantumOperators.matrix","text":"matrix(index::SpinIndex, graded::Graded, dtype::Type{<:Number}=ComplexF64) -> Matrix{dtype}\n\nGet the matrix representation of a SpinIndex on an Abelian graded space.\n\n\n\n\n\n","category":"function"},{"location":"manual/ExactDiagonalization/#QuantumLattices.QuantumOperators.matrix-Tuple{ED}","page":"Core of ExactDiagonalization","title":"QuantumLattices.QuantumOperators.matrix","text":"matrix(ed::ED, sectors::Union{Abelian, Sector}...; timer::TimerOutput=edtimer, release::Bool=false) -> OperatorSum{<:EDMatrix}\nmatrix(ed::Algorithm{<:ED}, sectors::Union{Abelian, Sector}...; release::Bool=false) -> OperatorSum{<:EDMatrix}\n\nGet the sparse matrix representation of a quantum lattice system in the target space.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.QuantumOperators.matrix-Union{Tuple{V}, Tuple{QuantumLattices.QuantumOperators.Operator{V, <:Tuple{QuantumLattices.QuantumOperators.OperatorIndex, Vararg{QuantumLattices.QuantumOperators.OperatorIndex, N}} where N}, Tuple{AbelianBases{‚Ñ§‚ÇÅ}, AbelianBases{‚Ñ§‚ÇÅ}}, AbstractDict}, Tuple{QuantumLattices.QuantumOperators.Operator{V, <:Tuple{QuantumLattices.QuantumOperators.OperatorIndex, Vararg{QuantumLattices.QuantumOperators.OperatorIndex, N}} where N}, Tuple{AbelianBases{‚Ñ§‚ÇÅ}, AbelianBases{‚Ñ§‚ÇÅ}}, AbstractDict, Any}} where V","page":"Core of ExactDiagonalization","title":"QuantumLattices.QuantumOperators.matrix","text":"matrix(op::Operator{V, <:OneAtLeast{OperatorIndex}}, braket::NTuple{2, AbelianBases}, table::AbstractDict, dtype=V) where V -> SparseMatrixCSC{dtype, Int}\n\nGet the CSC-formed sparse matrix representation of an operator.\n\nHere, table specifies the order of the operator indexes.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.QuantumOperators.matrix-Union{Tuple{V}, Tuple{QuantumLattices.QuantumOperators.Operator{V, <:Tuple{QuantumLattices.QuantumOperators.OperatorIndex, Vararg{QuantumLattices.QuantumOperators.OperatorIndex, N}} where N}, Tuple{BinaryBases, BinaryBases}, AbstractDict}, Tuple{QuantumLattices.QuantumOperators.Operator{V, <:Tuple{QuantumLattices.QuantumOperators.OperatorIndex, Vararg{QuantumLattices.QuantumOperators.OperatorIndex, N}} where N}, Tuple{BinaryBases, BinaryBases}, AbstractDict, Any}} where V","page":"Core of ExactDiagonalization","title":"QuantumLattices.QuantumOperators.matrix","text":"matrix(op::Operator{V, <:OneAtLeast{OperatorIndex}}, braket::NTuple{2, BinaryBases}, table::AbstractDict, dtype=V) where V -> SparseMatrixCSC{dtype, Int}\n\nGet the CSC-formed sparse matrix representation of an operator.\n\nHere, table specifies the order of the operator indexes.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.QuantumOperators.matrix-Union{Tuple{V}, Tuple{QuantumLattices.QuantumOperators.Operator{V, Tuple{}}, Tuple{Sector, Sector}, AbstractDict}, Tuple{QuantumLattices.QuantumOperators.Operator{V, Tuple{}}, Tuple{Sector, Sector}, AbstractDict, Any}} where V","page":"Core of ExactDiagonalization","title":"QuantumLattices.QuantumOperators.matrix","text":"matrix(op::Operator{V, Tuple{}}, braket::NTuple{2, Sector}, table::AbstractDict, dtype=V) where V -> SparseMatrixCSC{V, Int}\n\nGet the CSC-formed sparse matrix representation of a scalar operator.\n\n\n\n\n\n","category":"method"},{"location":"examples/Introduction/#examples","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"examples/Introduction/","page":"Introduction","title":"Introduction","text":"Here are some examples to illustrate how this package could be used.","category":"page"},{"location":"examples/Introduction/","page":"Introduction","title":"Introduction","text":"Pages = [\n        \"HubbardModel.md\",\n        \"HeisenbergModel.md\",\n        \"FractionalChernInsulatorOfHardCoreBosons.md\",\n        ]\nDepth = 2","category":"page"},{"location":"manual/QuantumNumbers/#Quantum-numbers","page":"Quantum numbers","title":"Quantum numbers","text":"","category":"section"},{"location":"manual/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"Quantum numbers can be considered as the conserved labels for the bases of a Hilbert space when a quantum system hosts some symmetries. Here we only implement Abelian quantum numbers because non-Abelian ones are far more complicated yet much less used.","category":"page"},{"location":"manual/QuantumNumbers/#AbelianQuantumNumber","page":"Quantum numbers","title":"AbelianQuantumNumber","text":"","category":"section"},{"location":"manual/QuantumNumbers/#RepresentationSpace","page":"Quantum numbers","title":"RepresentationSpace","text":"","category":"section"},{"location":"manual/QuantumNumbers/#qnmanual","page":"Quantum numbers","title":"Manual","text":"","category":"section"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.Abelian","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.Abelian","text":"const Abelian = AbelianQuantumNumber\n\nType alias for AbelianQuantumNumber.\n\n\n\n\n\n","category":"type"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.AbelianGradedSpace","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.AbelianGradedSpace","text":"AbelianGradedSpace(quantumnumbers::AbstractVector{<:AbelianQuantumNumber}, dimensions::AbstractVector{<:Integer}, dual::Bool=false; ordercheck::Bool=false, duplicatecheck::Bool=false, degeneracycheck::Bool=false)\n\nConstruct an Abelian graded space.\n\nHere:\n\nquantumnumbers specifies the Abelian quantum numbers labeling the irreducible representations of the corresponding Abelian group which must be sorted in the ascending order. Such an ordering should be manually guaranteed by the user. When and only when the keyword argument ordercheck is true, the constructor will check whether this condition is satisfied and raise an error if it doesn't. Besides, quantumnumbers must not contain duplicate Abelian quantum numbers, manually guaranteed by the user as well. This condition can be checked when and only when both ordercheck==true and duplicatecheck==true. An error will be raised if this check fails.\ndimensions specifies the degenerate dimensions of the corresponding Abelian quantum numbers. Apparently, each degenerate dimension must be positive, which should also be manually guaranteed by the user. When and only when the keyword argument degeneracycheck is true, the constructor will check whether this condition is satisfied and raise an error if it doesn't.\ndual specifies whether the graded space is the dual representation of the corresponding Abelian group, which roughly speaking, can be viewed as the direction of the arrow of the Abelian quantum numbers labeling the irreducible representations. We assume dual==true corresponds to the in-arrow and dual==false corresponds to the out-arrow.\n\n\n\n\n\n","category":"type"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.AbelianGradedSpace-2","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.AbelianGradedSpace","text":"AbelianGradedSpace{QN<:AbelianQuantumNumber} <: RepresentationSpace{QN}\n\nA quantum representation space of an Abelian group that has been decomposed into the direct sum of its irreducible representations.\n\n\n\n\n\n","category":"type"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.AbelianGradedSpace-Tuple{Any}","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.AbelianGradedSpace","text":"AbelianGradedSpace(pairs; dual::Bool=false)\nAbelianGradedSpace(pairs::Pair...; dual::Bool=false)\nAbelianGradedSpace{QN}(pairs; dual::Bool=false) where {QN<:AbelianQuantumNumber}\nAbelianGradedSpace{QN}(pairs::Pair...; dual::Bool=false) where {QN<:AbelianQuantumNumber}\n\nConstruct an Abelian graded space.\n\nIn this function, the Abelian quantum numbers will be sorted automatically, therefore, their orders need not be worried. Duplicate and dimension checks of the quantum numbers are also carried out and errors will be raised if either such checks fails.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.AbelianGradedSpaceProd","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.AbelianGradedSpaceProd","text":"AbelianGradedSpaceProd{N, QN<:AbelianQuantumNumber} <: CompositeAbelianGradedSpace{N, QN}\n\nDirect product of Abelian graded spaces.\n\n\n\n\n\n","category":"type"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.AbelianGradedSpaceSum","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.AbelianGradedSpaceSum","text":"AbelianGradedSpaceSum{N, QN<:AbelianQuantumNumber} <: CompositeAbelianGradedSpace{N, QN}\n\nDirect sum of Abelian graded spaces.\n\n\n\n\n\n","category":"type"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber","text":"AbelianQuantumNumber\n\nAbstract type of Abelian quantum numbers.\n\nAn Abelian quantum number is the label of a irreducible representation of an Abelian group acted on a quantum representation space. \n\n\n\n\n\n","category":"type"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.AbelianQuantumNumberProd","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.AbelianQuantumNumberProd","text":"AbelianQuantumNumberProd{T<:Tuple{Vararg{SimpleAbelianQuantumNumber}}} <: AbelianQuantumNumber\n\nDeligne tensor product of simple Abelian quantum numbers.\n\n\n\n\n\n","category":"type"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.AbelianQuantumNumberProd-Tuple{Vararg{SimpleAbelianQuantumNumber}}","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.AbelianQuantumNumberProd","text":"AbelianQuantumNumberProd(contents::SimpleAbelianQuantumNumber...)\nAbelianQuantumNumberProd(contents::Tuple{Vararg{SimpleAbelianQuantumNumber}})\n\nConstruct a Deligne tensor product of simple Abelian quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.AbelianQuantumNumberProd-Union{NTuple{N, Number}, Tuple{T}, Tuple{N}} where {N, T<:NTuple{N, SimpleAbelianQuantumNumber}}","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.AbelianQuantumNumberProd","text":"AbelianQuantumNumberProd{T}(vs::Vararg{Number, N}) where {N, T<:NTuple{N, SimpleAbelianQuantumNumber}}\nAbelianQuantumNumberProd{T}(vs::NTuple{N, Number}) where {N, T<:NTuple{N, SimpleAbelianQuantumNumber}}\n\nConstruct a Deligne tensor product of simple Abelian quantum numbers by their values.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.CompositeAbelianGradedSpace","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.CompositeAbelianGradedSpace","text":"CompositeAbelianGradedSpace{N, QN<:AbelianQuantumNumber} <: RepresentationSpace{QN}\n\nAbstract type of composite Abelian graded spaces.\n\n\n\n\n\n","category":"type"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.Graded","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.Graded","text":"const Graded = AbelianGradedSpace\n\nType alias for AbelianGradedSpace.\n\n\n\n\n\n","category":"type"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.RepresentationSpace","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.RepresentationSpace","text":"RepresentationSpace{QN<:AbelianQuantumNumber} <: VectorSpace{QN}\n\nAbstract type of quantum representation spaces of Abelian groups.\n\n\n\n\n\n","category":"type"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.SimpleAbelianQuantumNumber","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.SimpleAbelianQuantumNumber","text":"SimpleAbelianQuantumNumber <: AbelianQuantumNumber\n\nAbstract type of simple Abelian quantum numbers. That is, it contains only one label.\n\n\n\n\n\n","category":"type"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.f‚Ñ§‚ÇÇ","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.f‚Ñ§‚ÇÇ","text":"f‚Ñ§‚ÇÇ <: SimpleAbelianQuantumNumber\n\nFermion parity.\n\n\n\n\n\n","category":"type"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.s‚Ñ§‚ÇÇ","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.s‚Ñ§‚ÇÇ","text":"s‚Ñ§‚ÇÇ <: SimpleAbelianQuantumNumber\n\nSpin parity.\n\n\n\n\n\n","category":"type"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.‚Ñï","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.‚Ñï","text":"‚Ñï <: <: ùïå‚ÇÅ\n\nConcrete Abelian quantum number of the particle number.\n\n\n\n\n\n","category":"type"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.‚Ñ§","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.‚Ñ§","text":"‚Ñ§{N} <: SimpleAbelianQuantumNumber\n\n‚Ñ§‚Çô quantum numbers.\n\n\n\n\n\n","category":"type"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.‚Ñ§‚ÇÅ","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.‚Ñ§‚ÇÅ","text":"const ‚Ñ§‚ÇÅ = ‚Ñ§{1}\nconst ‚Ñ§‚ÇÇ = ‚Ñ§{2}\nconst ‚Ñ§‚ÇÉ = ‚Ñ§{3}\nconst ‚Ñ§‚ÇÑ = ‚Ñ§{4}\n\nAlias for ‚Ñ§‚ÇÅ/‚Ñ§‚ÇÇ/‚Ñ§‚ÇÉ/‚Ñ§‚ÇÑ quantum numbers.\n\n\n\n\n\n","category":"type"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.ùïä·∂ª","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.ùïä·∂ª","text":"ùïä·∂ª <: ùïå‚ÇÅ\n\nConcrete Abelian quantum number of the z-component of a spin.\n\n\n\n\n\n","category":"type"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.ùïå‚ÇÅ","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.ùïå‚ÇÅ","text":"ùïå‚ÇÅ <: SimpleAbelianQuantumNumber\n\nAbstract type of ùïå‚ÇÅ quantum numbers.\n\n\n\n\n\n","category":"type"},{"location":"manual/QuantumNumbers/#Base.:+-Tuple{ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber}","page":"Quantum numbers","title":"Base.:+","text":"+(qn::AbelianQuantumNumber) -> typeof(qn)\n\nOverloaded + operator for AbelianQuantumNumber.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.:+-Union{Tuple{QN}, Tuple{QN, QN, Vararg{QN}}} where QN<:ExactDiagonalization.QuantumNumbers.AbelianQuantumNumberProd","page":"Quantum numbers","title":"Base.:+","text":"+(qn‚ÇÅ::QN, qn‚ÇÇ::QN, qns::QN...) where {QN<:AbelianQuantumNumberProd} -> QN\n\nOverloaded + operator for AbelianQuantumNumberProd.\n\nnote: Note\nTo ensure type stability, two AbelianQuantumNumberProd can be added together if and only if they are of the same type.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.:+-Union{Tuple{QN}, Tuple{QN, QN, Vararg{QN}}} where QN<:SimpleAbelianQuantumNumber","page":"Quantum numbers","title":"Base.:+","text":"+(qn‚ÇÅ::QN, qn‚ÇÇ::QN, qns::QN...) where {QN<:SimpleAbelianQuantumNumber} -> QN\n\nOverloaded + operator for SimpleAbelianQuantumNumber.\n\nnote: Note\nTo ensure type stability, two SimpleAbelianQuantumNumber can be added together if and only if they are of the same type.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.:--Tuple{ExactDiagonalization.QuantumNumbers.AbelianQuantumNumberProd}","page":"Quantum numbers","title":"Base.:-","text":"-(qn::AbelianQuantumNumberProd) -> typeof(qn)\n-(qn‚ÇÅ::QN, qn‚ÇÇ::QN) where {QN<:AbelianQuantumNumberProd} -> QN\n\nOverloaded - operator for AbelianQuantumNumberProd.\n\nnote: Note\nTo ensure type stability, a AbelianQuantumNumberProd can be subtracted by another AbelianQuantumNumberProd if and only if they are of the same type.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.:--Tuple{SimpleAbelianQuantumNumber}","page":"Quantum numbers","title":"Base.:-","text":"-(qn::SimpleAbelianQuantumNumber) -> typeof(qn)\n-(qn‚ÇÅ::QN, qn‚ÇÇ::QN) where {QN<:SimpleAbelianQuantumNumber} -> QN\n\nOverloaded - operator for SimpleAbelianQuantumNumber.\n\nnote: Note\nTo ensure type stability, a SimpleAbelianQuantumNumber can be subtracted by another SimpleAbelianQuantumNumber if and only if they are of the same type.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.adjoint-Tuple{ExactDiagonalization.QuantumNumbers.AbelianGradedSpace}","page":"Quantum numbers","title":"Base.adjoint","text":"adjoint(gs::AbelianGradedSpace) -> typeof(gs)\n\nGet the dual of an Abelian graded space.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.cumsum-Tuple{ExactDiagonalization.QuantumNumbers.RepresentationSpace, Union{Integer, CartesianIndex}}","page":"Quantum numbers","title":"Base.cumsum","text":"cumsum(rs::RepresentationSpace, i::Union{Integer, CartesianIndex}) -> Int\n\nGet the accumulative degenerate dimension up to the ith Abelian quantum number contained in a representation space.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.cumsum-Union{Tuple{QN}, Tuple{ExactDiagonalization.QuantumNumbers.AbelianGradedSpace{QN}, QN}} where QN<:ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber","page":"Quantum numbers","title":"Base.cumsum","text":"cumsum(gs::AbelianGradedSpace{QN}, qn::QN) where {QN<:AbelianQuantumNumber} -> Int\n\nGet the accumulative dimension of an Abelian graded space up to a certain Abelian quantum number contained in an Abelian graded space.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.getindex-Tuple{ExactDiagonalization.QuantumNumbers.AbelianGradedSpace, AbstractVector{<:Integer}}","page":"Quantum numbers","title":"Base.getindex","text":"getindex(gs::AbelianGradedSpace, indexes::AbstractVector{<:Integer}) -> typeof(gs)\ngetindex(gs::AbelianGradedSpace{QN}, quantumnumbers::AbstractVector{QN}) where {QN<:AbelianQuantumNumber} -> AbelianGradedSpace{QN}\n\nGet a subset of an Abelian graded space.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.getindex-Tuple{ExactDiagonalization.QuantumNumbers.AbelianQuantumNumberProd, Integer}","page":"Quantum numbers","title":"Base.getindex","text":"getindex(qn::AbelianQuantumNumberProd, i::Integer) -> SimpleAbelianQuantumNumber\n\nGet the ith simple Abelian quantum number in a Deligne tensor product.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.getindex-Union{Tuple{T}, Tuple{Type{ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber}, Type{T}}} where T<:ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber","page":"Quantum numbers","title":"Base.getindex","text":"getindex(::Type{Abelian}, ::Type{T}) where {T<:AbelianQuantumNumber} -> Type{T}\n\nOverloaded [] for Abelian, i.e., the support of syntax Abelian[T] where T<:AbelianQuantumNumber, which is helpful for the construction of tensor producted Abelian quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.in-Union{Tuple{QN}, Tuple{QN, ExactDiagonalization.QuantumNumbers.AbelianGradedSpace{QN}}} where QN<:ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber","page":"Quantum numbers","title":"Base.in","text":"in(qn::QN, gs::AbelianGradedSpace{QN}) where {QN<:AbelianQuantumNumber} -> Bool\n\nCheck whether an Abelian quantum number is contained in an Abelian graded space.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.inv","page":"Quantum numbers","title":"Base.inv","text":"inv(qn::AbelianQuantumNumber, bool::Bool=true) -> typeof(qn)\n\nGet the inverse of an Abelian quantum number qn if bool is true. Otherwise, return qn itself.\n\n\n\n\n\n","category":"function"},{"location":"manual/QuantumNumbers/#Base.length-Tuple{ExactDiagonalization.QuantumNumbers.AbelianGradedSpace}","page":"Quantum numbers","title":"Base.length","text":"length(gs::AbelianGradedSpace) -> Int\n\nGet the number of inequivalent irreducible representations (i.e., the Abelian quantum numbers) of an Abelian graded space.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.length-Tuple{ExactDiagonalization.QuantumNumbers.AbelianQuantumNumberProd}","page":"Quantum numbers","title":"Base.length","text":"length(qn::AbelianQuantumNumberProd) -> Int\n\nGet the length of a Deligne tensor product.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.merge-Tuple{ExactDiagonalization.QuantumNumbers.AbelianGradedSpaceProd}","page":"Quantum numbers","title":"Base.merge","text":"merge(rs::AbelianGradedSpaceProd) -> Tuple{AbelianGradedSpace{eltype(rs)}, Dict{eltype(rs), Vector{NTuple{rank(rs), eltype(rs)}}}}\n\nGet the decomposition of the direct product of several Abelian graded spaces and its corresponding fusion processes.\n\nFor a set of Abelian graded spaces (gs‚ÇÅ, gs‚ÇÇ, ...), their direct product space can contain several equivalent irreducible representations because for different sets of Abelian quantum numbers (qn‚ÇÅ, qn‚ÇÇ, ...) where qn·µ¢‚ààgs·µ¢, the fusion, i.e., ‚äó(qn‚ÇÅ, qn‚ÇÇ, ...) may give the same result qn. This function returns the decomposition of the direct product of (gs‚ÇÅ, gs‚ÇÇ, ...) as well as all the fusion processes of each quantum number contained in the decomposition.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.pairs-Tuple{ExactDiagonalization.QuantumNumbers.RepresentationSpace, typeof(dimension)}","page":"Quantum numbers","title":"Base.pairs","text":"pairs(rs::RepresentationSpace, ::typeof(dimension)) -> RepresentationSpacePairs\npairs(rs::RepresentationSpace, ::typeof(range)) -> RepresentationSpacePairs\n\nReturn an iterator that iterates over the pairs of the Abelian quantum numbers and their corresponding (slices of the) degenerate dimensions contained in a representation space.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.range-Tuple{ExactDiagonalization.QuantumNumbers.AbelianGradedSpace, CartesianIndex}","page":"Quantum numbers","title":"Base.range","text":"range(gs::AbelianGradedSpace, qn::CartesianIndex) -> UnitRange{Int}\nrange(gs::AbelianGradedSpace{QN}, qn::QN) where {QN<:AbelianQuantumNumber} -> UnitRange{Int}\n\nGet the slice of the degenerate dimension of an Abelian quantum number contained in an Abelian graded space.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.range-Tuple{ExactDiagonalization.QuantumNumbers.AbelianGradedSpaceProd, CartesianIndex}","page":"Quantum numbers","title":"Base.range","text":"range(rs::AbelianGradedSpaceProd, i::CartesianIndex) -> AbstractVector{Int}\n\nGet the slice of the degenerate dimension of the ith Abelian quantum number in the direct product of several Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.range-Tuple{ExactDiagonalization.QuantumNumbers.AbelianGradedSpaceSum, CartesianIndex}","page":"Quantum numbers","title":"Base.range","text":"range(rs::AbelianGradedSpaceSum, i::CartesianIndex) -> UnitRange{Int}\n\nGet the slice of the degenerate dimension of the ith Abelian quantum number in the direct sum of several Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.range-Tuple{ExactDiagonalization.QuantumNumbers.RepresentationSpace, Integer}","page":"Quantum numbers","title":"Base.range","text":"range(rs::RepresentationSpace, i::Integer)\n\nGet the slice of the degenerate dimension of the ith Abelian quantum number contained in a representation space.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.range-Union{Tuple{QN}, Tuple{N}, Tuple{ExactDiagonalization.QuantumNumbers.AbelianGradedSpaceProd{N, QN}, NTuple{N, QN}}} where {N, QN<:ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber}","page":"Quantum numbers","title":"Base.range","text":"range(rs::AbelianGradedSpaceProd{N, QN}, qns::NTuple{N, QN}) where {N, QN<:AbelianQuantumNumber} -> AbstractVector{Int}\n\nGet the slice of the degenerate dimension of the Abelian quantum number fused by qns in the direct product of several Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.split-Union{Tuple{QN}, Tuple{N}, Tuple{QN, ExactDiagonalization.QuantumNumbers.AbelianGradedSpaceProd{N, QN}}} where {N, QN<:ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber}","page":"Quantum numbers","title":"Base.split","text":"split(target::QN, rs::AbelianGradedSpaceProd{N, QN}; nmax::Real=20) where {N, QN<:AbelianQuantumNumber} -> Set{NTuple{N, QN}}\n\nFind a set of splittings of the target Abelian quantum number with respect to the direct product of several Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.values-Tuple{ExactDiagonalization.QuantumNumbers.AbelianQuantumNumberProd}","page":"Quantum numbers","title":"Base.values","text":"values(qn::AbelianQuantumNumberProd) -> NTuple{rank(qn), Number}\n\nGet the values of the simple Abelian quantum numbers in a Deligne tensor product.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.values-Tuple{SimpleAbelianQuantumNumber}","page":"Quantum numbers","title":"Base.values","text":"values(qn::SimpleAbelianQuantumNumber) -> Tuple{Number}\n\nGet the value of a simple Abelian quantum number and return it as the sole element of a tuple.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#Base.zero-Tuple{ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber}","page":"Quantum numbers","title":"Base.zero","text":"zero(qn::AbelianQuantumNumber) -> typeof(qn)\nzero(::Type{QN}) where {QN<:AbelianQuantumNumber} -> QN\n\nGet the zero Abelian quantum number.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.:‚ä†-Tuple{SimpleAbelianQuantumNumber, Vararg{SimpleAbelianQuantumNumber}}","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.:‚ä†","text":"‚ä†(qn::SimpleAbelianQuantumNumber, qns::SimpleAbelianQuantumNumber...) -> AbelianQuantumNumberProd\n‚ä†(qn‚ÇÅ::SimpleAbelianQuantumNumber, qn‚ÇÇ::AbelianQuantumNumberProd) -> AbelianQuantumNumberProd\n‚ä†(qn‚ÇÅ::AbelianQuantumNumberProd, qn‚ÇÇ::SimpleAbelianQuantumNumber) -> AbelianQuantumNumberProd\n‚ä†(qn‚ÇÅ::AbelianQuantumNumberProd, qn‚ÇÇ::AbelianQuantumNumberProd) -> AbelianQuantumNumberProd\n\nDeligne tensor product of Abelian quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.:‚ä†-Tuple{Type{<:SimpleAbelianQuantumNumber}, Vararg{Type{<:SimpleAbelianQuantumNumber}}}","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.:‚ä†","text":"‚ä†(QN::Type{<:SimpleAbelianQuantumNumber}, QNS::Type{<:SimpleAbelianQuantumNumber}...) -> Type{AbelianQuantumNumberProd{Tuple{QN, QNS...}}}\n‚ä†(::Type{QN}, ::Type{AbelianQuantumNumberProd{T}}) where {QN<:SimpleAbelianQuantumNumber, T<:Tuple{Vararg{SimpleAbelianQuantumNumber}}} -> Type{AbelianQuantumNumberProd{Tuple{QN, fieldtypes(T)...}}}\n‚ä†(::Type{AbelianQuantumNumberProd{T}}, ::Type{QN}) where {T<:Tuple{Vararg{SimpleAbelianQuantumNumber}}, QN<:SimpleAbelianQuantumNumber} -> Type{AbelianQuantumNumberProd{Tuple{fieldtypes(T)...}, QN}}\n‚ä†(::Type{AbelianQuantumNumberProd{T‚ÇÅ}}, ::Type{AbelianQuantumNumberProd{T‚ÇÇ}}) where {T‚ÇÅ<:Tuple{Vararg{SimpleAbelianQuantumNumber}}, T‚ÇÇ<:Tuple{Vararg{SimpleAbelianQuantumNumber}}} -> Type{AbelianQuantumNumberProd{Tuple{fieldtypes(T‚ÇÅ)..., fieldtypes(T‚ÇÇ)...}}}\n\nDeligne tensor product of Abelian quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.findindex-Tuple{Integer, ExactDiagonalization.QuantumNumbers.AbelianGradedSpace, Integer}","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.findindex","text":"findindex(position::Integer, gs::AbelianGradedSpace, guess::Integer) -> Int\n\nFind the index of an Abelian quantum number in an Abelian graded space beginning at guess whose position in the complete dimension range is position.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.regularize!-Tuple{Vector{<:ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber}, Vector{Int64}}","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.regularize!","text":"regularize!(quantumnumbers::Vector{<:AbelianQuantumNumber}, dimensions::Vector{Int}; check::Bool=false) -> Tuple{typeof(quantumnumbers), typeof(dimensions), Vector{Int}}\n\nIn place regularization of the input Abelian quantum numbers and their corresponding degenerate dimensions.\n\nAfter the regularization, the Abelian quantum numbers will be sorted in the ascending order and duplicates will be merged together. The degenerate dimensions will be processed accordingly. When check is true, this function also check whether all input degenerate dimensions are positive. The regularized Abelian quantum numbers and degenerate dimensions, as well as the permutation vector that sorts the input Abelian quantum numbers, will be returned. \n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#ExactDiagonalization.QuantumNumbers.regularize-Tuple{AbstractVector{<:ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber}, AbstractVector{<:Integer}}","page":"Quantum numbers","title":"ExactDiagonalization.QuantumNumbers.regularize","text":"regularize(quantumnumbers::AbstractVector{<:AbelianQuantumNumber}, dimension::AbstractVector{<:Integer}; check::Bool=false) -> Tuple{Vector{eltype(quantumnumbers)}, Vector{Int}, Vector{Int}}\n\nRegularize of the input Abelian quantum numbers and their corresponding degenerate dimensions.\n\nSee regularize!.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#LinearAlgebra.rank-Tuple{ExactDiagonalization.QuantumNumbers.AbelianQuantumNumberProd}","page":"Quantum numbers","title":"LinearAlgebra.rank","text":"rank(qn::AbelianQuantumNumberProd) -> Int\nrank(::Type{<:AbelianQuantumNumberProd}) -> Int\n\nGet the rank of a Deligne tensor product of simple Abelian quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#LinearAlgebra.rank-Tuple{ExactDiagonalization.QuantumNumbers.CompositeAbelianGradedSpace}","page":"Quantum numbers","title":"LinearAlgebra.rank","text":"rank(rs::CompositeAbelianGradedSpace) -> Int\nrank(::Type{<:CompositeAbelianGradedSpace{N}}) where N -> Int\n\nGet the number of Abelian graded spaces in the direct sum.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#QuantumLattices.:‚äï-Tuple{ExactDiagonalization.QuantumNumbers.AbelianGradedSpace, Vararg{ExactDiagonalization.QuantumNumbers.AbelianGradedSpace}}","page":"Quantum numbers","title":"QuantumLattices.:‚äï","text":"‚äï(gs::AbelianGradedSpace, gses::AbelianGradedSpace...) -> AbelianGradedSpaceSum\n‚äï(gs::AbelianGradedSpace, rs::AbelianGradedSpaceSum) -> AbelianGradedSpaceSum\n‚äï(rs::AbelianGradedSpaceSum, gs::AbelianGradedSpace) -> AbelianGradedSpaceSum\n‚äï(rs‚ÇÅ::AbelianGradedSpaceSum, rs‚ÇÇ::AbelianGradedSpaceSum) -> AbelianGradedSpaceSum\n\nGet the direct sum of some Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#QuantumLattices.:‚äó-Tuple{ExactDiagonalization.QuantumNumbers.AbelianGradedSpace, Vararg{ExactDiagonalization.QuantumNumbers.AbelianGradedSpace}}","page":"Quantum numbers","title":"QuantumLattices.:‚äó","text":"‚äó(gs::AbelianGradedSpace, gses::AbelianGradedSpace...) -> AbelianGradedSpaceProd\n‚äó(gs::AbelianGradedSpace, rs::AbelianGradedSpaceProd) -> AbelianGradedSpaceProd\n‚äó(rs::AbelianGradedSpaceProd, gs::AbelianGradedSpace) -> AbelianGradedSpaceProd\n‚äó(rs‚ÇÅ::AbelianGradedSpaceProd, rs‚ÇÇ::AbelianGradedSpaceProd) -> AbelianGradedSpaceProd\n\nGet the direct product of some Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#QuantumLattices.:‚äó-Tuple{ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber, Vararg{ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber}}","page":"Quantum numbers","title":"QuantumLattices.:‚äó","text":"‚äó(qn::AbelianQuantumNumber, qns::AbelianQuantumNumber...) -> eltype(qns)\n\nGet the direct product of some AbelianQuantumNumbers.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#QuantumLattices.Spatials.period-Tuple{ExactDiagonalization.QuantumNumbers.AbelianQuantumNumberProd, Integer}","page":"Quantum numbers","title":"QuantumLattices.Spatials.period","text":"period(qn::AbelianQuantumNumberProd, i::Integer) -> Number\nperiod(::Type{AbelianQuantumNumberProd{T}}, i::Integer) where {T<:Tuple{Vararg{SimpleAbelianQuantumNumber}}} -> Number\n\nGet the period of the ith simple Abelian number contained in a Deligne tensor product.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#QuantumLattices.Spatials.period-Tuple{SimpleAbelianQuantumNumber}","page":"Quantum numbers","title":"QuantumLattices.Spatials.period","text":"period(qn::SimpleAbelianQuantumNumber) -> Number\nperiod(::Type{QN}) where {QN<:SimpleAbelianQuantumNumber} -> Number\n\nGet the period of a simple Abelian quantum number.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#QuantumLattices.Spatials.periods-Tuple{ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber}","page":"Quantum numbers","title":"QuantumLattices.Spatials.periods","text":"periods(qn::AbelianQuantumNumber) -> Tuple{Vararg{Number}}\nperiods(::Type{QN}) where {QN<:AbelianQuantumNumber} -> Tuple{Vararg{Number}}\n\nGet the periods of Abelian quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#QuantumLattices.decompose-Tuple{ExactDiagonalization.QuantumNumbers.CompositeAbelianGradedSpace}","page":"Quantum numbers","title":"QuantumLattices.decompose","text":"decompose(rs::CompositeAbelianGradedSpace; expand::Bool=true) -> Tuple{AbelianGradedSpace{eltype(rs)}, Vector{Int}}\n\nDecompose a composite of several Abelian graded spaces to the canonical one.\n\nWhen expand is false, the corresponding permutation vector that sorts the Abelian quantum numbers will be returned as well. When expand is true, the expanded dimension indexes of the permutation vector that sorts the Abelian quantum numbers will be returned as well.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#QuantumLattices.dimension-Tuple{ExactDiagonalization.QuantumNumbers.AbelianGradedSpace, CartesianIndex}","page":"Quantum numbers","title":"QuantumLattices.dimension","text":"dimension(gs::AbelianGradedSpace, qn::CartesianIndex) -> Int\ndimension(gs::AbelianGradedSpace{QN}, qn::QN) where {QN<:AbelianQuantumNumber} -> Int\n\nGet the degenerate dimension of an Abelian quantum number contained in an Abelian graded space.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#QuantumLattices.dimension-Tuple{ExactDiagonalization.QuantumNumbers.AbelianGradedSpaceProd, CartesianIndex}","page":"Quantum numbers","title":"QuantumLattices.dimension","text":"dimension(rs::AbelianGradedSpaceProd, i::CartesianIndex) -> Int\n\nGet the degenerate dimension of the ith Abelian quantum number in the direct product of several Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#QuantumLattices.dimension-Tuple{ExactDiagonalization.QuantumNumbers.AbelianGradedSpaceProd}","page":"Quantum numbers","title":"QuantumLattices.dimension","text":"dimension(rs::AbelianGradedSpaceProd) -> Int\n\nGet the total dimension of the direct product of several Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#QuantumLattices.dimension-Tuple{ExactDiagonalization.QuantumNumbers.AbelianGradedSpaceSum, CartesianIndex}","page":"Quantum numbers","title":"QuantumLattices.dimension","text":"dimension(rs::AbelianGradedSpaceSum, i::CartesianIndex) -> Int\n\nGet the degenerate dimension of the ith Abelian quantum number in the direct sum of several Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#QuantumLattices.dimension-Tuple{ExactDiagonalization.QuantumNumbers.AbelianGradedSpaceSum}","page":"Quantum numbers","title":"QuantumLattices.dimension","text":"dimension(rs::AbelianGradedSpaceSum) -> Int\n\nGet the total dimension of the direct sum of several Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#QuantumLattices.dimension-Tuple{ExactDiagonalization.QuantumNumbers.AbelianGradedSpace}","page":"Quantum numbers","title":"QuantumLattices.dimension","text":"dimension(gs::AbelianGradedSpace) -> Int\n\nGet the total dimension of an Abelian graded space.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#QuantumLattices.dimension-Tuple{ExactDiagonalization.QuantumNumbers.RepresentationSpace, Integer}","page":"Quantum numbers","title":"QuantumLattices.dimension","text":"dimension(rs::RepresentationSpace, i::Integer) -> Int\n\nGet the degenerate dimension of the ith Abelian quantum number contained in a representation space.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#QuantumLattices.dimension-Union{Tuple{QN}, Tuple{N}, Tuple{ExactDiagonalization.QuantumNumbers.AbelianGradedSpaceProd{N, QN}, NTuple{N, QN}}} where {N, QN<:ExactDiagonalization.QuantumNumbers.AbelianQuantumNumber}","page":"Quantum numbers","title":"QuantumLattices.dimension","text":"dimension(rs::AbelianGradedSpaceProd{N, QN}, qns::NTuple{N, QN}) where {N, QN<:AbelianQuantumNumber} -> Int\n\nGet the degenerate dimension of the Abelian quantum number fused by qns in the direct product of several Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#QuantumLattices.value-Tuple{ExactDiagonalization.QuantumNumbers.AbelianQuantumNumberProd, Integer}","page":"Quantum numbers","title":"QuantumLattices.value","text":"value(qn::AbelianQuantumNumberProd, i::Integer) -> Number\n\nGet the value of the ith simple Abelian quantum number in a Deligne tensor product.\n\n\n\n\n\n","category":"method"},{"location":"manual/QuantumNumbers/#QuantumLattices.value-Tuple{SimpleAbelianQuantumNumber}","page":"Quantum numbers","title":"QuantumLattices.value","text":"value(qn::SimpleAbelianQuantumNumber) -> Number\n\nGet the value of a simple Abelian quantum number.\n\n\n\n\n\n","category":"method"},{"location":"#ExactDiagonalization","page":"Home","title":"ExactDiagonalization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: CI) (Image: codecov) (Image: ) (Image: ) (Image: 996.icu) (Image: LICENSE) (Image: LICENSE) (Image: Code Style: Blue) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia package for the exact diagonalization method in condensed matter physics.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Based on the symbolic operator representation of a quantum lattice system in condensed matter physics that is generated by the package QuantumLattices, exact diagonalization method is implemented for fermionic, hard-core-bosonic and spin systems.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In Julia v1.8+, please type ] in the REPL to use the package mode, then type this command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add ExactDiagonalization","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Examples of exact diagonalization method for quantum lattice system","category":"page"},{"location":"#Note","page":"Home","title":"Note","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Due to the fast development of this package, releases with different minor version numbers are not guaranteed to be compatible with previous ones before the release of v1.0.0. Comments are welcomed in the issues.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"waltergu1989@gmail.com","category":"page"},{"location":"#Python-counterpart","page":"Home","title":"Python counterpart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HamiltonianPy: in fact, the authors of this Julia package worked on the python package at first and only turned to Julia later.","category":"page"},{"location":"examples/HubbardModel/#Fermi-Hubbard-Model-on-square-lattice","page":"Fermi Hubbard Model on square lattice","title":"Fermi Hubbard Model on square lattice","text":"","category":"section"},{"location":"examples/HubbardModel/#Ground-state-energy","page":"Fermi Hubbard Model on square lattice","title":"Ground state energy","text":"","category":"section"},{"location":"examples/HubbardModel/","page":"Fermi Hubbard Model on square lattice","title":"Fermi Hubbard Model on square lattice","text":"The following codes could compute the ground state energy of the Fermi Hubbard model on square lattice.","category":"page"},{"location":"examples/HubbardModel/","page":"Fermi Hubbard Model on square lattice","title":"Fermi Hubbard Model on square lattice","text":"using QuantumLattices\nusing ExactDiagonalization\nusing LinearAlgebra: eigen\n\n# define the unitcell of the square lattice\nunitcell = Lattice([0.0, 0.0]; name=:Square, vectors=[[1.0, 0.0], [0.0, 1.0]])\n\n# define a finite 3√ó4 cluster of the square lattice with open boundary condition\nlattice = Lattice(unitcell, (3, 4))\n\n# define the Hilbert space (single-orbital spin-1/2 complex fermion)\nhilbert = Hilbert(site=>Fock{:f}(1, 2) for site=1:length(lattice))\n\n# define the quantum number of the sub-Hilbert space in which the computation to be carried out\n# here the particle number is set to be `length(lattice)` and Sz is set to be 0\nquantumnumber = ‚Ñï(length(lattice)) ‚ä† ùïä·∂ª(0)\n\n# define the terms, i.e. the nearest-neighbor hopping and the Hubbard interaction\nt = Hopping(:t, -1.0, 1)\nU = Hubbard(:U, 8.0)\n\n# define the exact diagonalization algorithm for the Fermi Hubbard model\ned = ED(lattice, hilbert, (t, U), quantumnumber)\n\n# find the ground state and its energy\neigensystem = eigen(ed; nev=1)\n\n# Ground state energy should be -4.913259209075605\nprint(eigensystem.values)","category":"page"}]
}
