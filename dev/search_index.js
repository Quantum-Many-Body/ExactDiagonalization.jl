var documenterSearchIndex = {"docs":
[{"location":"examples/FractionalChernInsulatorOfHardCoreBosons/#Fractional-Chern-Insulator-of-Hard-core-Bosons-on-honeycomb-lattice","page":"Fractional Chern Insulator of Hard-core Bosons on honeycomb lattice","title":"Fractional Chern Insulator of Hard-core Bosons on honeycomb lattice","text":"","category":"section"},{"location":"examples/FractionalChernInsulatorOfHardCoreBosons/#Many-body-energy-levels-as-a-function-of-twisted-boundary-conditions","page":"Fractional Chern Insulator of Hard-core Bosons on honeycomb lattice","title":"Many-body energy levels as a function of twisted boundary conditions","text":"","category":"section"},{"location":"examples/FractionalChernInsulatorOfHardCoreBosons/","page":"Fractional Chern Insulator of Hard-core Bosons on honeycomb lattice","title":"Fractional Chern Insulator of Hard-core Bosons on honeycomb lattice","text":"The following codes could compute the many-body energy levels as a function of twisted boundary conditions of hard-core bosons on honeycomb lattice with a nearly-flat Chern band.","category":"page"},{"location":"examples/FractionalChernInsulatorOfHardCoreBosons/","page":"Fractional Chern Insulator of Hard-core Bosons on honeycomb lattice","title":"Fractional Chern Insulator of Hard-core Bosons on honeycomb lattice","text":"using QuantumLattices\nusing ExactDiagonalization\nusing LinearAlgebra: eigen\nusing Plots: plot\n\n# unit cell of the honeycomb lattice\nunitcell = Lattice([0.0, 0.0], [0.0, ‚àö3/3]; vectors=[[1.0, 0.0], [0.5, ‚àö3/2]])\n\n# 4√ó3 cluster\nlattice = Lattice(unitcell, (4, 3), ('P', 'P'))\n\n# twisted boundary condition\nboundary = Boundary{(:Œ∏‚ÇÅ, :Œ∏‚ÇÇ)}([0.0, 0.0], lattice.vectors)\n\n# Hilbert space of hard-core bosons\nhilbert = Hilbert(Fock{:b}(1, 1), length(lattice))\n\n# Parameters of the model, with hoppings up to 3rd nearest neighbor and interactions up to 2nd\n# the 2nd nearest neighbor hopping is complex, similar to that of the Haldane model\n# with such parameters, the model host a nearly flat band with ¬±1 Chern number\nparameters = (\n    t=Complex(-1.0), t‚Ä≤=Complex(-0.6), t‚Ä≤‚Ä≤=Complex(0.58), œÜ=0.4, V‚ÇÅ=1.0, V‚ÇÇ=0.4, Œ∏‚ÇÅ=0.0, Œ∏‚ÇÇ=0.0\n)\nmap(parameters::NamedTuple) = (\n    t‚ÇÅ=parameters.t,\n    t‚ÇÇ=parameters.t‚Ä≤*cos(parameters.œÜ*pi),\n    Œª‚ÇÇ=parameters.t‚Ä≤*sin(parameters.œÜ*pi),\n    t‚ÇÉ=parameters.t‚Ä≤‚Ä≤,\n    V‚ÇÅ=parameters.V‚ÇÅ,\n    V‚ÇÇ=parameters.V‚ÇÇ,\n    Œ∏‚ÇÅ=parameters.Œ∏‚ÇÅ,\n    Œ∏‚ÇÇ=parameters.Œ∏‚ÇÇ\n)\n\n# terms\nt‚ÇÅ = Hopping(:t‚ÇÅ, map(parameters).t‚ÇÅ, 1; ismodulatable=false)\nt‚ÇÇ = Hopping(:t‚ÇÇ, map(parameters).t‚ÇÇ, 2; ismodulatable=false)\nŒª‚ÇÇ = Hopping(:Œª‚ÇÇ, map(parameters).Œª‚ÇÇ, 2;\n    amplitude=bond::Bond->1im*cos(3*azimuth(rcoordinate(bond)))*(-1)^(bond[1].site%2),\n    ismodulatable=false\n)\nt‚ÇÉ = Hopping(:t‚ÇÉ, map(parameters).t‚ÇÉ, 3; ismodulatable=false)\nV‚ÇÅ = Coulomb(:V‚ÇÅ, map(parameters).V‚ÇÅ, 1)\nV‚ÇÇ = Coulomb(:V‚ÇÇ, map(parameters).V‚ÇÇ, 2)\n\n# 1/4 filling of the model, i.e., half-filling of the lower flat Chern band\n# In such case, the ground state of the model is a bosonic fractional Chern insulator\n# see Y.-F. Wang, et al. PRL 107, 146803 (2011)\nquantumnumber = ‚Ñï(length(lattice)√∑4)\n\n# construct the algorithm\nfci = Algorithm(\n    :FCI,\n    ED(lattice, hilbert, (t‚ÇÅ, t‚ÇÇ, Œª‚ÇÇ, t‚ÇÉ, V‚ÇÅ, V‚ÇÇ), quantumnumber, boundary),\n    parameters,\n    map\n)\n\n# define the boundary angles and number of energy levels to be computed\nnŒ∏, nev = 5, 3\nŒ∏s = range(0, 2, nŒ∏)\ndata = zeros(nŒ∏, nev)\n\n# compute the energy levels with different twist boundary angles\nfor (i, Œ∏) in enumerate(Œ∏s)\n    update!(fci; Œ∏‚ÇÅ=Œ∏)\n    data[i, :] = eigen(fci; nev=nev).values\nend\n\n# plot the result\nplot(Œ∏s, data; legend=false)","category":"page"},{"location":"examples/HeisenbergModel/#Antiferromagnetic-Heisenberg-Model-on-square-lattice","page":"Antiferromagnetic Heisenberg Model on square lattice","title":"Antiferromagnetic Heisenberg Model on square lattice","text":"","category":"section"},{"location":"examples/HeisenbergModel/#Ground-state-energy","page":"Antiferromagnetic Heisenberg Model on square lattice","title":"Ground state energy","text":"","category":"section"},{"location":"examples/HeisenbergModel/","page":"Antiferromagnetic Heisenberg Model on square lattice","title":"Antiferromagnetic Heisenberg Model on square lattice","text":"The following codes could compute the ground state energy of the antiferromagnetic Heisenberg model on square lattice.","category":"page"},{"location":"examples/HeisenbergModel/","page":"Antiferromagnetic Heisenberg Model on square lattice","title":"Antiferromagnetic Heisenberg Model on square lattice","text":"using QuantumLattices\nusing ExactDiagonalization\nusing LinearAlgebra: eigen\n\n# define the unitcell of the square lattice\nunitcell = Lattice([0.0, 0.0]; name=:Square, vectors=[[1.0, 0.0], [0.0, 1.0]])\n\n# define a finite 4√ó4 cluster of the square lattice with open boundary condition\nlattice = Lattice(unitcell, (4, 4))\n\n# define the Hilbert space (spin-1/2)\nhilbert = Hilbert(Spin{1//2}(), length(lattice))\n\n# define the quantum number of the sub-Hilbert space in which the computation to be carried out\n# for the ground state, Sz=0\nquantumnumber = ùïä·∂ª(0)\n\n# define the antiferromagnetic Heisenberg term on the nearest neighbor\nJ = Heisenberg(:J, 1.0, 1)\n\n# define the exact diagonalization algorithm for the antiferromagnetic Heisenberg model\ned = ED(lattice, hilbert, J, quantumnumber)\n\n# find the ground state and its energy\neigensystem = eigen(ed; nev=1)\n\n# Ground state energy should be -9.189207065192935\nprint(eigensystem.values)","category":"page"},{"location":"manual/BandLanczos/#Band-Lanczos","page":"Band Lanczos","title":"Band Lanczos","text":"","category":"section"},{"location":"manual/BandLanczos/#ExactDiagonalization.BandLanczos.BandLanczosFactorization","page":"Band Lanczos","title":"ExactDiagonalization.BandLanczos.BandLanczosFactorization","text":"BandLanczosFactorization{T, S<:Number, SR<:Real} <: KrylovFactorization{T, S}\n\nBand Lanczos factorization, same to KrylovKit.BlockLanczosFactorization except that the Krylov basis vectors can be chosen to be kept or not.\n\n\n\n\n\n","category":"type"},{"location":"manual/BandLanczos/#ExactDiagonalization.BandLanczos.BandLanczosIterator","page":"Band Lanczos","title":"ExactDiagonalization.BandLanczos.BandLanczosIterator","text":"BandLanczosIterator{F, T, S<:Real} <: KrylovIterator{F, T}\n\nBand Lanczos iterator.\n\n\n\n\n\n","category":"type"},{"location":"manual/BandLanczos/#ExactDiagonalization.BandLanczos.BandLanczosIterator-Union{Tuple{T}, Tuple{Any, KrylovKit.Block{T}, Int64}, Tuple{Any, KrylovKit.Block{T}, Int64, Real}} where T","page":"Band Lanczos","title":"ExactDiagonalization.BandLanczos.BandLanczosIterator","text":"BandLanczosIterator(operator, x‚ÇÄ::Block, maxdim::Int, tol::Real=1e-12; keepvecs::Bool=true)\n\nConstruct a BandLanczosIterator.\n\n\n\n\n\n","category":"method"},{"location":"manual/BandLanczos/#KrylovKit.expand!-Tuple{ExactDiagonalization.BandLanczos.BandLanczosIterator, ExactDiagonalization.BandLanczos.BandLanczosFactorization}","page":"Band Lanczos","title":"KrylovKit.expand!","text":"expand!(iter::BandLanczosIterator, state::BandLanczosFactorization) -> BandLanczosFactorization\n\nExpand an BandLanczosFactorization.\n\n\n\n\n\n","category":"method"},{"location":"manual/BandLanczos/#KrylovKit.initialize-Tuple{ExactDiagonalization.BandLanczos.BandLanczosIterator}","page":"Band Lanczos","title":"KrylovKit.initialize","text":"initialize(iter::BandLanczosIterator) -> BandLanczosFactorization\n\nInitialize a BandLanczosFactorization by a BandLanczosIterator.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Core-of-ExactDiagonalization","page":"Core of ExactDiagonalization","title":"Core of ExactDiagonalization","text":"","category":"section"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.basicoptions","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.basicoptions","text":"const basicoptions = (\n    nev = \"number of eigenvalues to be computed\",\n    which = \"type of eigenvalues to be computed\",\n    tol = \"tolerance of the computation\",\n    maxiter = \"maximum iteration of the computation\",\n    v‚ÇÄ = \"initial state\",\n    krylovdim = \"maximum dimension of the Krylov subspace that will be constructed\",\n    verbosity = \"verbosity level\"\n)\n\nBasic options of actions for exact diagonalization method.\n\n\n\n\n\n","category":"constant"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.edtimer","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.edtimer","text":"const edtimer = TimerOutput()\n\nDefault shared timer for all exact diagonalization methods.\n\n\n\n\n\n","category":"constant"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.AbelianBases","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.AbelianBases","text":"AbelianBases{A<:Abelian, N} <: Sector\n\nA set of Abelian bases, that is, a set of bases composed from the product of local Abelian Graded spaces.\n\nTo improve the efficiency of the product of local Abelian Graded spaces, we adopt a two-step strategy:\n\npartition the local spaces into several groups in each of which the local spaces are direct producted and rearranged according to the Abelian quantum numbers, and then \nglue the results obtained in the previous step so that a sector with a certain Abelian quantum number can be targeted.\n\nIn principle, a binary-tree strategy can be more efficient, but our two-step strategy is enough for a quantum system that can be solved by the exact diagonalization method.\n\nThe partition of the local Abelian Graded spaces is assigned by a NTuple{N, Vector{Int}}, with each of its element contains the sequences of the grouped local spaces specified by a table.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.AbelianBases-Union{Tuple{AbstractVector{Int64}}, Tuple{N}, Tuple{AbstractVector{Int64}, NTuple{N, AbstractVector{Int64}}}} where N","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.AbelianBases","text":"AbelianBases(locals::AbstractVector{Int}, partition::NTuple{N, AbstractVector{Int}}=partition(length(locals))) where N\n\nConstruct a set of spin bases that subjects to no quantum number conservation.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.AbelianBases-Union{Tuple{A}, Tuple{N}, Tuple{Array{QuantumLattices.QuantumNumbers.AbelianGradedSpace{A}, 1}, A}, Tuple{Array{QuantumLattices.QuantumNumbers.AbelianGradedSpace{A}, 1}, A, NTuple{N, AbstractVector{Int64}}}} where {N, A<:QuantumLattices.QuantumNumbers.AbelianQuantumNumber}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.AbelianBases","text":"AbelianBases(locals::Vector{Graded{A}}, quantumnumber::A, partition::NTuple{N, AbstractVector{Int}}=partition(length(locals))) where {N, A<:Abelian}\n\nConstruct a set of spin bases that preserves a certain symmetry specified by the corresponding Abelian quantum number.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.BinaryBases","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.BinaryBases","text":"BinaryBases{A<:Abelian, B<:BinaryBasis, T<:AbstractVector{B}} <: Sector\n\nA set of binary bases.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.BinaryBases-Tuple{Any, Any, ‚Ñï ‚ä† ùïä·∂ª}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.BinaryBases","text":"BinaryBases(spindws, spinups, spinfulparticle::Abelian[‚Ñï ‚ä† ùïä·∂ª])\nBinaryBases(spindws, spinups, spinfulparticle::Abelian[ùïä·∂ª ‚ä† ‚Ñï])\n\nConstruct a set of binary bases that preserves both the particle number and the spin z-component conservation.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.BinaryBases-Tuple{Any, Any, ùïä·∂ª}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.BinaryBases","text":"BinaryBases(spindws, spinups, sz::ùïä·∂ª)\n\nConstruct a set of binary bases that preserves the spin z-component but not the particle number conservation.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.BinaryBases-Tuple{Integer, ‚Ñï}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.BinaryBases","text":"BinaryBases(states, particle::‚Ñï)\nBinaryBases(nstate::Integer, particle::‚Ñï)\n\nConstruct a set of binary bases that preserves the particle number conservation.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.BinaryBases-Tuple{Integer}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.BinaryBases","text":"BinaryBases(states)\nBinaryBases(nstate::Integer)\n\nConstruct a set of binary bases that subjects to no quantum number conservation.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.BinaryBasis","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.BinaryBasis","text":"BinaryBasis{I<:Unsigned}\n\nBinary basis represented by an unsigned integer.\n\nHere, we adopt the following common rules:\n\nIn a binary basis, a bit of an unsigned integer represents a single-particle state that can be occupied (1) or unoccupied (0).\nThe position of this bit in the unsigned integer counting from the right corresponds to the sequence of the single-particle state specified by a table.\nWhen representing a many-body state by creation operators, they are arranged in ascending order according to their sequences.\n\nIn this way, any many-body state of canonical fermionic or hardcore bosonic systems can be represented ambiguously by the binary bases, e.g., c^_2c^_3c^_4textVacuumrangle is represented by 1110.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.BinaryBasis-Tuple{Any}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.BinaryBasis","text":"BinaryBasis(states; filter=index->true)\nBinaryBasis{I}(states; filter=index->true) where {I<:Unsigned}\n\nConstruct a binary basis with the given occupied states.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.BinaryBasisRange","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.BinaryBasisRange","text":"BinaryBasisRange{I<:Unsigned} <: VectorSpace{BinaryBasis{I}}\n\nA continuous range of binary basis from 0 to 2^n-1.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.ED","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.ED","text":"ED(\n    lattice::AbstractLattice, hilbert::Hilbert, terms::OneOrMore{Term}, quantumnumbers::OneOrMore{Abelian}, boundary::Boundary=plain, dtype::Type{<:Number}=valtype(terms);\n    neighbors::Union{Int, Neighbors}=nneighbor(terms)\n)\nED(\n    lattice::AbstractLattice, hilbert::Hilbert, terms::OneOrMore{Term}, table::AbstractDict, quantumnumbers::OneOrMore{Abelian}, boundary::Boundary=plain, dtype::Type{<:Number}=valtype(terms);\n    neighbors::Union{Int, Neighbors}=nneighbor(terms)\n)\n\nConstruct the exact diagonalization method for a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.ED-2","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.ED","text":"ED(\n    lattice::AbstractLattice, hilbert::Hilbert, terms::OneOrMore{Term}, boundary::Boundary=plain, dtype::Type{<:Number}=valtype(terms);\n    neighbors::Union{Int, Neighbors}=nneighbor(terms)\n)\nED(\n    lattice::AbstractLattice, hilbert::Hilbert, terms::OneOrMore{Term}, table::AbstractDict, sectors::OneOrMore{Sector}=Sector(hilbert; table=table), boundary::Boundary=plain, dtype::Type{<:Number}=valtype(terms);\n    neighbors::Union{Int, Neighbors}=nneighbor(terms)\n)\n\nConstruct the exact diagonalization method for a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.ED-3","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.ED","text":"ED(system::Generator{<:Operators}, table::AbstractDict, sectors::OneOrMore{Sector}, dtype::Type{<:Number}=scalartype(system))\nED(lattice::Union{AbstractLattice, Nothing}, system::Generator{<:Operators}, table::AbstractDict, sectors::OneOrMore{Sector}, dtype::Type{<:Number}=scalartype(system))\n\nConstruct the exact diagonalization method for a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.ED-4","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.ED","text":"ED{K<:EDKind, L<:Union{AbstractLattice, Nothing}, S<:Generator{<:Operators}, M<:EDMatrixization, H<:CategorizedGenerator{<:OperatorSum{<:EDMatrix}}} <: Frontend\n\nExact diagonalization method of a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDEigen","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDEigen","text":"EDEigen{S<:Tuple{Vararg{Union{Abelian, Sector}}}} <: Action\n\nEigen system by exact diagonalization method.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDEigen-Tuple{Vararg{Union{Sector, QuantumLattices.QuantumNumbers.AbelianQuantumNumber}}}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDEigen","text":"EDEigen(sectors::Union{Abelian, Sector}...)\nEDEigen(sectors:::Tuple{Vararg{Union{Abelian, Sector}}})\n\nConstruct an EDEigen.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDEigenData","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDEigenData","text":"EDEigenData{V<:Number, T<:Number, S<:Sector} <: Data\n\nEigen decomposition in exact diagonalization method.\n\nCompared to the usual eigen decomposition Eigen, EDEigenData contains a :sectors attribute to store the sectors of Hilbert space in which the eigen values and eigen vectors are computed. Furthermore, given that in different sectors the dimensions of the sub-Hilbert spaces can also be different, the :vectors attribute of EDEigenData is a vector of vector instead of a matrix.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDKind","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDKind","text":"EDKind{K}\n\nKind of the exact diagonalization method applied to a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDKind-Tuple{Type{<:QuantumLattices.QuantumSystems.FockIndex}}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDKind","text":"EDKind(::Type{<:FockIndex})\n\nKind of the exact diagonalization method applied to a canonical quantum Fock lattice system.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDKind-Tuple{Type{<:QuantumLattices.QuantumSystems.SpinIndex}}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDKind","text":"EDKind(::Type{<:SpinIndex})\n\nKind of the exact diagonalization method applied to a canonical quantum spin lattice system.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDMatrix","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDMatrix","text":"EDMatrix{M<:SparseMatrixCSC, S<:Sector} <: OperatorPack{M, Tuple{S, S}}\n\nMatrix representation of quantum operators between a ket Hilbert space and a bra Hilbert space.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDMatrix-Tuple{SparseArrays.SparseMatrixCSC, Sector}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDMatrix","text":"EDMatrix(m::SparseMatrixCSC, sector::Sector)\nEDMatrix(m::SparseMatrixCSC, braket::NTuple{2, Sector})\nEDMatrix(m::SparseMatrixCSC, bra::Sector, ket::Sector)\n\nConstruct a matrix representation when\n\nthe bra and ket Hilbert spaces share the same bases;\nthe bra and ket Hilbert spaces may be different;\nthe bra and ket Hilbert spaces may or may not be the same.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDMatrixization","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDMatrixization","text":"EDMatrixization{D<:Number, T<:AbstractDict, S<:Sector} <: Matrixization\n\nMatrixization of a quantum lattice system on a target Hilbert space.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.EDMatrixization-Union{Tuple{S}, Tuple{D}, Tuple{AbstractDict, S, Vararg{S}}} where {D<:Number, S<:Sector}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.EDMatrixization","text":"EDMatrixization{D}(table::AbstractDict, sector::S, sectors::S...) where {D<:Number, S<:Sector}\nEDMatrixization{D}(table::AbstractDict, brakets::Vector{Tuple{S, S}}) where {D<:Number, S<:Sector}\n\nConstruct a matrixization.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.GroundStateExpectation","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.GroundStateExpectation","text":"GroundStateExpectation{D<:Number, O<:Array{<:Union{Operator, Operators}}} <: Action\n\nGround state expectation of operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.GroundStateExpectationData","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.GroundStateExpectationData","text":"GroundStateExpectationData{A<:Array{<:Number}} <: Data\n\nData of ground state expectation of operators, including:\n\nvalues::A: values of the ground state expectation.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.Sector","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.Sector","text":"Sector(hilbert::Hilbert{<:Fock}, basistype::Type{<:Unsigned}=UInt) -> BinaryBases\nSector(quantumnumber::‚Ñï, hilbert::Hilbert{<:Fock}, basistype::Type{<:Unsigned}=UInt; table::AbstractDict=Table(hilbert, Metric(EDKind(hilbert), hilbert))) -> BinaryBases\nSector(quantumnumber::Union{ùïä·∂ª, Abelian[‚Ñï ‚ä† ùïä·∂ª], Abelian[ùïä·∂ª ‚ä† ‚Ñï]}, hilbert::Hilbert{<:Fock}, basistype::Type{<:Unsigned}=UInt; table::AbstractDict=Table(hilbert, Metric(EDKind(hilbert), hilbert))) -> BinaryBases\n\nConstruct the binary bases of a Hilbert space with the specified quantum number.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.Sector-2","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.Sector","text":"Sector\n\nA sector of the Hilbert space which forms the bases of an irreducible representation of the Hamiltonian of a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.Sector-3","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.Sector","text":"Sector(hilbert::Hilbert{<:Spin}, partition::Tuple{Vararg{AbstractVector{Int}}}=partition(length(hilbert))) -> AbelianBases\nSector(\n    quantumnumber::Abelian, hilbert::Hilbert{<:Spin}, partition::Tuple{Vararg{AbstractVector{Int}}}=partition(length(hilbert));\n    table::AbstractDict=Table(hilbert, Metric(EDKind(hilbert), hilbert))\n) -> AbelianBases\n\nConstruct the Abelian bases of a spin Hilbert space with the specified quantum number.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.SectorFilter","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.SectorFilter","text":"SectorFilter{S} <: LinearTransformation\n\nFilter the target bra and ket Hilbert spaces.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.SpinCoherentState","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.SpinCoherentState","text":"(state::SpinCoherentState)(bases::AbelianBases, table::AbstractDict, dtype=ComplexF64) -> Vector{dtype}\n\nGet the vector representation of a spin coherent state with the given Abelian bases and table.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.SpinCoherentState-2","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.SpinCoherentState","text":"SpinCoherentState <: CompositeDict{Int, Tuple{Float64, Float64}}\n\nSpin coherent state on a block of lattice sites.\n\nThe structure of the spin coherent state is specified by a Dict{Int, Tuple{Float64, Float64}}, which contains the site-(Œ∏, œï) pairs with site being the site index in a lattice and (Œ∏, œï) denoting the polar and azimuth angles in radians of the classical magnetic moment on this site.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.SpinCoherentState-Tuple{AbstractDict{Int64, <:AbstractVector{<:Number}}}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.SpinCoherentState","text":"SpinCoherentState(structure::AbstractDict{Int, <:AbstractVector{<:Number}})\nSpinCoherentState(structure::AbstractDict{Int, <:NTuple{2, Number}}; unit::Symbol=:radian)\n\nConstruct a spin coherent state on a block of lattice sites.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.SpinCoherentStateProjection","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.SpinCoherentStateProjection","text":"SpinCoherentStateProjection <: Action\n\nProjection of states obtained by exact diagonalization method onto spin coherent states.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.SpinCoherentStateProjection-Tuple{SpinCoherentState, Integer, Integer}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.SpinCoherentStateProjection","text":"SpinCoherentStateProjection(configuration::SpinCoherentState, polars::AbstractVector{<:Real}, azimuths::AbstractVector{<:Real})\nSpinCoherentStateProjection(configuration::SpinCoherentState, np::Integer, na::Integer)\n\nConstruct a SpinCoherentStateProjection.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.SpinCoherentStateProjectionData","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.SpinCoherentStateProjectionData","text":"SpinCoherentStateProjectionData <: Data\n\nData of spin coherent state projection, including:\n\npolars::Vector{Float64}: global polar angles of the spin coherent states.\nazimuths::Vector{Float64}: global azimuth angles of the spin coherent states.\nvalues::Matrix{Float64}: projection of the state obtained by exact diagonalization method onto the spin coherent states.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.StaticTwoPointCorrelator","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.StaticTwoPointCorrelator","text":"StaticTwoPointCorrelator{O<:Union{Operator, Operators}, R<:ReciprocalSpace} <: Action\n\nStatic two-point correlation function.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.StaticTwoPointCorrelatorData","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.StaticTwoPointCorrelatorData","text":"StaticTwoPointCorrelatorData{R<:ReciprocalSpace, V<:Array{Float64}} <: Data\n\nData of static two-point correlation function, including:\n\nreciprocalspace::R: reciprocal space to compute the static two-point correlation function.\nvalues::V: values of the static two-point correlation function.\n\n\n\n\n\n","category":"type"},{"location":"manual/ExactDiagonalization/#QuantumLattices.DegreesOfFreedom.Metric-Tuple{EDKind{:Abelian}, QuantumLattices.DegreesOfFreedom.Hilbert{<:QuantumLattices.QuantumSystems.Spin}}","page":"Core of ExactDiagonalization","title":"QuantumLattices.DegreesOfFreedom.Metric","text":"Metric(::EDKind{:Abelian}, ::Hilbert{<:Spin}) -> OperatorIndexToTuple\n\nGet the index-to-tuple metric for a canonical quantum spin lattice system.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.DegreesOfFreedom.Metric-Tuple{EDKind{:Binary}, QuantumLattices.DegreesOfFreedom.Hilbert{<:QuantumLattices.QuantumSystems.Fock}}","page":"Core of ExactDiagonalization","title":"QuantumLattices.DegreesOfFreedom.Metric","text":"Metric(::EDKind{:Binary}, ::Hilbert{<:Fock}) -> OperatorIndexToTuple\n\nGet the index-to-tuple metric for a canonical quantum Fock lattice system.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.QuantumNumbers.Abelian-Tuple{AbelianBases}","page":"Core of ExactDiagonalization","title":"QuantumLattices.QuantumNumbers.Abelian","text":"Abelian(bs::AbelianBases)\n\nGet the Abelian quantum number of a set of spin bases.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.QuantumNumbers.Abelian-Tuple{BinaryBases}","page":"Core of ExactDiagonalization","title":"QuantumLattices.QuantumNumbers.Abelian","text":"Abelian(bs::BinaryBases)\n\nGet the Abelian quantum number of a set of binary bases.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.QuantumNumbers.Graded-Union{Tuple{QuantumLattices.QuantumSystems.Spin}, Tuple{‚Ñ§‚ÇÅ}} where ‚Ñ§‚ÇÅ","page":"Core of ExactDiagonalization","title":"QuantumLattices.QuantumNumbers.Graded","text":"Graded{‚Ñ§‚ÇÅ}(spin::Spin)\nGraded{ùïä·∂ª}(spin::Spin)\n\nDecompose a local spin space into an Abelian graded space that preserves 1) no symmetry, and 2) spin-z component symmetry.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.Broadcast.broadcast-Tuple{Type{Sector}, Tuple{QuantumLattices.QuantumNumbers.AbelianQuantumNumber, Vararg{QuantumLattices.QuantumNumbers.AbelianQuantumNumber, N}} where N, QuantumLattices.DegreesOfFreedom.Hilbert, Vararg{Any}}","page":"Core of ExactDiagonalization","title":"Base.Broadcast.broadcast","text":"broadcast(::Type{Sector}, quantumnumbers::OneAtLeast{Abelian}, hilbert::Hilbert, args...; table::AbstractDict=Table(hilbert, Metric(EDKind(hilbert), hilbert))) -> NTuple{fieldcount(typeof(quantumnumbers)), Sector}\n\nConstruct a set of sectors based on the quantum numbers and a Hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.Broadcast.broadcast-Union{Tuple{A}, Tuple{N}, Tuple{Type{Sector}, Tuple{A, Vararg{A, N}} where N, QuantumLattices.DegreesOfFreedom.Hilbert{<:QuantumLattices.QuantumSystems.Spin}}, Tuple{Type{Sector}, Tuple{A, Vararg{A, N}} where N, QuantumLattices.DegreesOfFreedom.Hilbert{<:QuantumLattices.QuantumSystems.Spin}, NTuple{N, AbstractVector{Int64}}}} where {N, A<:QuantumLattices.QuantumNumbers.AbelianQuantumNumber}","page":"Core of ExactDiagonalization","title":"Base.Broadcast.broadcast","text":"broadcast(\n    ::Type{Sector}, quantumnumbers::OneAtLeast{Abelian}, hilbert::Hilbert{<:Spin}, partition::NTuple{N, AbstractVector{Int}}=partition(length(hilbert));\n    table::AbstractDict=Table(hilbert, Metric(EDKind(hilbert), hilbert))\n) where N -> NTuple{fieldcount(typeof(quantumnumbers)), AbelianBases}\n\nConstruct a set of Abelian based based on the quantum numbers and a Hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.count-Tuple{BinaryBasis}","page":"Core of ExactDiagonalization","title":"Base.count","text":"count(basis::BinaryBasis) -> Int\ncount(basis::BinaryBasis, start::Integer, stop::Integer) -> Int\n\nCount the number of occupied single-particle states for a binary basis.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.count-Tuple{EDEigenData}","page":"Core of ExactDiagonalization","title":"Base.count","text":"count(data::EDEigenData) -> Int\n\nCount the number of eigen value-vector-sector groups contained in an EDEigenData.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.isone-Tuple{BinaryBasis, Integer}","page":"Core of ExactDiagonalization","title":"Base.isone","text":"isone(basis::BinaryBasis, state::Integer) -> Bool\n\nJudge whether the specified single-particle state is occupied for a binary basis.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.iszero-Tuple{BinaryBasis, Integer}","page":"Core of ExactDiagonalization","title":"Base.iszero","text":"iszero(basis::BinaryBasis, state::Integer) -> Bool\n\nJudge whether the specified single-particle state is unoccupied for a binary basis.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.iterate","page":"Core of ExactDiagonalization","title":"Base.iterate","text":"iterate(basis::BinaryBasis)\niterate(basis::BinaryBasis, state)\n\nIterate over the numbers of the occupied single-particle states.\n\n\n\n\n\n","category":"function"},{"location":"manual/ExactDiagonalization/#Base.match-Tuple{Sector, Sector}","page":"Core of ExactDiagonalization","title":"Base.match","text":"match(sector‚ÇÅ::Sector, sector‚ÇÇ::Sector) -> Bool\n\nJudge whether two sectors match each other, that is, whether they can be used together as the bra and ket spaces.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.one-Tuple{BinaryBasis, Integer}","page":"Core of ExactDiagonalization","title":"Base.one","text":"one(basis::BinaryBasis, state::Integer) -> BinaryBasis\n\nGet a new binary basis with the specified single-particle state occupied.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.range-Tuple{AbelianBases{‚Ñ§‚ÇÅ}}","page":"Core of ExactDiagonalization","title":"Base.range","text":"range(bs::AbelianBases) -> AbstractVector{Int}\n\nGet the range of the target sector of an AbelianBases in the direct producted bases.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#Base.zero-Tuple{BinaryBasis, Integer}","page":"Core of ExactDiagonalization","title":"Base.zero","text":"zero(basis::BinaryBasis, state::Integer) -> BinaryBasis\n\nGet a new binary basis with the specified single-particle state unoccupied.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.basistype-Tuple{Integer}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.basistype","text":"basistype(i::Integer)\nbasistype(::Type{I}) where {I<:Integer}\n\nGet the binary basis type corresponding to an integer or a type of an integer.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.prepare!-Tuple{ED}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.prepare!","text":"prepare!(ed::ED; timer::TimerOutput=edtimer) -> ED\nprepare!(ed::Algorithm{<:ED}) -> Algorithm{<:ED}\n\nPrepare the matrix representation.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.productable-Tuple{Sector, Sector}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.productable","text":"productable(sector‚ÇÅ::Sector, sector‚ÇÇ::Sector) -> Bool\n\nJudge whether two sectors could be direct producted.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.release!-Tuple{ED}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.release!","text":"release!(ed::ED; gc::Bool=true) -> ED\nrelease!(ed::Algorithm{<:ED}; gc::Bool=true) -> Algorithm{<:ED}\n\nRelease the memory source used in preparing the matrix representation. If gc is true, call the garbage collection immediately.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#ExactDiagonalization.sumable-Tuple{Sector, Sector}","page":"Core of ExactDiagonalization","title":"ExactDiagonalization.sumable","text":"sumable(sector‚ÇÅ::Sector, sector‚ÇÇ::Sector) -> Bool\n\nJudge whether two sectors could be direct summed.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#LinearAlgebra.eigen-Tuple{ED, Vararg{Union{Sector, QuantumLattices.QuantumNumbers.AbelianQuantumNumber}}}","page":"Core of ExactDiagonalization","title":"LinearAlgebra.eigen","text":"eigen(ed::ED, sectors::Union{Abelian, Sector}...; timer::TimerOutput=edtimer, release::Bool=false, kwargs...) -> EDEigenData\neigen(ed::Algorithm{<:ED}, sectors::Union{Abelian, Sector}...; release::Bool=false, kwargs...) -> EDEigenData\n\nSolve the eigen problem by the restarted Lanczos method provided by the Arpack package.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#LinearAlgebra.eigen-Tuple{EDMatrix}","page":"Core of ExactDiagonalization","title":"LinearAlgebra.eigen","text":"eigen(m::EDMatrix; nev::Int=1, which::Symbol=:SR, tol::Real=1e-12, maxiter::Int=300, v‚ÇÄ::Union{AbstractVector{<:Number}, Int}=dimension(m.bra), krylovdim::Int=max(20, 2*nev+1), verbosity::Int=0) -> EDEigenData\n\nSolve the eigen problem by the restarted Lanczos method provided by the KrylovKit package.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#LinearAlgebra.eigen-Tuple{QuantumLattices.QuantumOperators.OperatorSum{<:EDMatrix}}","page":"Core of ExactDiagonalization","title":"LinearAlgebra.eigen","text":"eigen(\n    ms::OperatorSum{<:EDMatrix};\n    nev::Int=1,\n    which::Symbol=:SR,\n    tol::Real=1e-12,\n    maxiter::Int=300,\n    v‚ÇÄ::Union{Dict{<:Abelian, <:Union{AbstractVector{<:Number}, Int}}, Dict{<:Sector, <:Union{AbstractVector{<:Number}, Int}}}=Dict(Abelian(m.ket)=>dimension(m.ket) for m in ms),\n    krylovdim::Int=max(20, 2*nev+1),\n    verbosity::Int=0,\n    timer::TimerOutput=edtimer\n) -> EDEigenData\n\nSolve the eigen problem by the restarted Lanczos method provided by the Arpack package.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.:‚äó-Tuple{BinaryBases, BinaryBases}","page":"Core of ExactDiagonalization","title":"QuantumLattices.:‚äó","text":"‚äó(bs‚ÇÅ::BinaryBases, bs‚ÇÇ::BinaryBases) -> BinaryBases\n\nGet the direct product of two sets of binary bases.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.:‚äó-Tuple{BinaryBasis, BinaryBasis}","page":"Core of ExactDiagonalization","title":"QuantumLattices.:‚äó","text":"‚äó(basis‚ÇÅ::BinaryBasis, basis‚ÇÇ::BinaryBasis) -> BinaryBasis\n\nGet the direct product of two binary bases.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.:‚ä†-Tuple{BinaryBases, QuantumLattices.QuantumNumbers.AbelianQuantumNumber}","page":"Core of ExactDiagonalization","title":"QuantumLattices.:‚ä†","text":"‚ä†(bs::BinaryBases, another::Abelian) -> BinaryBases\n‚ä†(another::Abelian, bs::BinaryBases) -> BinaryBases\n\nDeligne tensor product the quantum number of a set of binary bases with another quantum number.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.DegreesOfFreedom.partition-Tuple{Int64}","page":"Core of ExactDiagonalization","title":"QuantumLattices.DegreesOfFreedom.partition","text":"partition(n::Int) -> NTuple{2, Vector{Int}}\n\nGet the default partition of n local Hilbert spaces.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.QuantumOperators.matrix","page":"Core of ExactDiagonalization","title":"QuantumLattices.QuantumOperators.matrix","text":"matrix(ops::Operators, braket::NTuple{2, Sector}, table::AbstractDict, dtype=scalartype(ops)) -> SparseMatrixCSC{dtype, Int}\n\nGet the CSC-formed sparse matrix representation of a set of operators.\n\nHere, table specifies the order of the operator indexes.\n\n\n\n\n\n","category":"function"},{"location":"manual/ExactDiagonalization/#QuantumLattices.QuantumOperators.matrix-2","page":"Core of ExactDiagonalization","title":"QuantumLattices.QuantumOperators.matrix","text":"matrix(index::OperatorIndex, graded::Graded, dtype::Type{<:Number}=ComplexF64) -> Matrix{dtype}\n\nGet the matrix representation of an OperatorIndex on an Abelian graded space.\n\n\n\n\n\n","category":"function"},{"location":"manual/ExactDiagonalization/#QuantumLattices.QuantumOperators.matrix-3","page":"Core of ExactDiagonalization","title":"QuantumLattices.QuantumOperators.matrix","text":"matrix(index::SpinIndex, graded::Graded, dtype::Type{<:Number}=ComplexF64) -> Matrix{dtype}\n\nGet the matrix representation of a SpinIndex on an Abelian graded space.\n\n\n\n\n\n","category":"function"},{"location":"manual/ExactDiagonalization/#QuantumLattices.QuantumOperators.matrix-Tuple{ED}","page":"Core of ExactDiagonalization","title":"QuantumLattices.QuantumOperators.matrix","text":"matrix(ed::ED, sectors::Union{Abelian, Sector}...; timer::TimerOutput=edtimer, release::Bool=false) -> OperatorSum{<:EDMatrix}\nmatrix(ed::Algorithm{<:ED}, sectors::Union{Abelian, Sector}...; release::Bool=false) -> OperatorSum{<:EDMatrix}\n\nGet the sparse matrix representation of a quantum lattice system in the target space.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.QuantumOperators.matrix-Union{Tuple{V}, Tuple{QuantumLattices.QuantumOperators.Operator{V, <:Tuple{QuantumLattices.QuantumOperators.OperatorIndex, Vararg{QuantumLattices.QuantumOperators.OperatorIndex, N}} where N}, Tuple{AbelianBases{‚Ñ§‚ÇÅ}, AbelianBases{‚Ñ§‚ÇÅ}}, AbstractDict}, Tuple{QuantumLattices.QuantumOperators.Operator{V, <:Tuple{QuantumLattices.QuantumOperators.OperatorIndex, Vararg{QuantumLattices.QuantumOperators.OperatorIndex, N}} where N}, Tuple{AbelianBases{‚Ñ§‚ÇÅ}, AbelianBases{‚Ñ§‚ÇÅ}}, AbstractDict, Any}} where V","page":"Core of ExactDiagonalization","title":"QuantumLattices.QuantumOperators.matrix","text":"matrix(op::Operator{V, <:OneAtLeast{OperatorIndex}}, braket::NTuple{2, AbelianBases}, table::AbstractDict, dtype=V) where V -> SparseMatrixCSC{dtype, Int}\n\nGet the CSC-formed sparse matrix representation of an operator.\n\nHere, table specifies the order of the operator indexes.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.QuantumOperators.matrix-Union{Tuple{V}, Tuple{QuantumLattices.QuantumOperators.Operator{V, <:Tuple{QuantumLattices.QuantumOperators.OperatorIndex, Vararg{QuantumLattices.QuantumOperators.OperatorIndex, N}} where N}, Tuple{BinaryBases, BinaryBases}, AbstractDict}, Tuple{QuantumLattices.QuantumOperators.Operator{V, <:Tuple{QuantumLattices.QuantumOperators.OperatorIndex, Vararg{QuantumLattices.QuantumOperators.OperatorIndex, N}} where N}, Tuple{BinaryBases, BinaryBases}, AbstractDict, Any}} where V","page":"Core of ExactDiagonalization","title":"QuantumLattices.QuantumOperators.matrix","text":"matrix(op::Operator{V, <:OneAtLeast{OperatorIndex}}, braket::NTuple{2, BinaryBases}, table::AbstractDict, dtype=V) where V -> SparseMatrixCSC{dtype, Int}\n\nGet the CSC-formed sparse matrix representation of an operator.\n\nHere, table specifies the order of the operator indexes.\n\n\n\n\n\n","category":"method"},{"location":"manual/ExactDiagonalization/#QuantumLattices.QuantumOperators.matrix-Union{Tuple{V}, Tuple{QuantumLattices.QuantumOperators.Operator{V, Tuple{}}, Tuple{Sector, Sector}, AbstractDict}, Tuple{QuantumLattices.QuantumOperators.Operator{V, Tuple{}}, Tuple{Sector, Sector}, AbstractDict, Any}} where V","page":"Core of ExactDiagonalization","title":"QuantumLattices.QuantumOperators.matrix","text":"matrix(op::Operator{V, Tuple{}}, braket::NTuple{2, Sector}, table::AbstractDict, dtype=V) where V -> SparseMatrixCSC{V, Int}\n\nGet the CSC-formed sparse matrix representation of a scalar operator.\n\n\n\n\n\n","category":"method"},{"location":"examples/Introduction/#examples","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"examples/Introduction/","page":"Introduction","title":"Introduction","text":"Here are some examples to illustrate how this package could be used.","category":"page"},{"location":"examples/Introduction/","page":"Introduction","title":"Introduction","text":"Pages = [\n        \"HubbardModel.md\",\n        \"HeisenbergModel.md\",\n        \"FractionalChernInsulatorOfHardCoreBosons.md\",\n        ]\nDepth = 2","category":"page"},{"location":"#ExactDiagonalization","page":"Home","title":"ExactDiagonalization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: CI) (Image: codecov) (Image: ) (Image: ) (Image: 996.icu) (Image: LICENSE) (Image: LICENSE) (Image: Code Style: Blue) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia package for the exact diagonalization method in condensed matter physics.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Based on the symbolic operator representation of a quantum lattice system in condensed matter physics that is generated by the package QuantumLattices, exact diagonalization method is implemented for fermionic, hard-core-bosonic and spin systems.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In Julia v1.8+, please type ] in the REPL to use the package mode, then type this command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add ExactDiagonalization","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Examples of exact diagonalization method for quantum lattice system","category":"page"},{"location":"#Note","page":"Home","title":"Note","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Due to the fast development of this package, releases with different minor version numbers are not guaranteed to be compatible with previous ones before the release of v1.0.0. Comments are welcomed in the issues.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"waltergu1989@gmail.com","category":"page"},{"location":"#Python-counterpart","page":"Home","title":"Python counterpart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HamiltonianPy: in fact, the authors of this Julia package worked on the python package at first and only turned to Julia later.","category":"page"},{"location":"examples/HubbardModel/#Fermi-Hubbard-Model-on-square-lattice","page":"Fermi Hubbard Model on square lattice","title":"Fermi Hubbard Model on square lattice","text":"","category":"section"},{"location":"examples/HubbardModel/#Ground-state-energy","page":"Fermi Hubbard Model on square lattice","title":"Ground state energy","text":"","category":"section"},{"location":"examples/HubbardModel/","page":"Fermi Hubbard Model on square lattice","title":"Fermi Hubbard Model on square lattice","text":"The following codes could compute the ground state energy of the Fermi Hubbard model on square lattice.","category":"page"},{"location":"examples/HubbardModel/","page":"Fermi Hubbard Model on square lattice","title":"Fermi Hubbard Model on square lattice","text":"using QuantumLattices\nusing ExactDiagonalization\nusing LinearAlgebra: eigen\n\n# define the unitcell of the square lattice\nunitcell = Lattice([0.0, 0.0]; name=:Square, vectors=[[1.0, 0.0], [0.0, 1.0]])\n\n# define a finite 3√ó4 cluster of the square lattice with open boundary condition\nlattice = Lattice(unitcell, (3, 4))\n\n# define the Hilbert space (single-orbital spin-1/2 complex fermion)\nhilbert = Hilbert(site=>Fock{:f}(1, 2) for site=1:length(lattice))\n\n# define the quantum number of the sub-Hilbert space in which the computation to be carried out\n# here the particle number is set to be `length(lattice)` and Sz is set to be 0\nquantumnumber = ‚Ñï(length(lattice)) ‚ä† ùïä·∂ª(0)\n\n# define the terms, i.e. the nearest-neighbor hopping and the Hubbard interaction\nt = Hopping(:t, -1.0, 1)\nU = Hubbard(:U, 8.0)\n\n# define the exact diagonalization algorithm for the Fermi Hubbard model\ned = ED(lattice, hilbert, (t, U), quantumnumber)\n\n# find the ground state and its energy\neigensystem = eigen(ed; nev=1)\n\n# Ground state energy should be -4.913259209075605\nprint(eigensystem.values)","category":"page"}]
}
